#!/bin/sh
#
# SliTaz Build Bot. The Cooker is a tool to automate and test SliTaz package
# building. Please read the Cookbook documentation for more information
# and discuss with the AUTHORS before adding anything here. PS: no translations
# here since it's not an end user tool and it's not useful. All devs should
# at least understand basic English.
#
. /usr/lib/slitaz/libcook.sh
. /usr/lib/slitaz/libcookorder.sh

# Set pkg name and use same wok as cook.
pkg="$2"

# PID file.
pidfile='/var/run/cooker.pid'
COMMAND="$1"

#
# Functions
#

usage() {
	cat << EOT

Usage: cooker [command] [pkg|list|note|hours]

Options:
  usage|-u        $(gettext "Display this short usage.")
  setup|-s        $(gettext "Setup the Cooker environment.")
  setup-cron      $(gettext "Setup a cron job for the Cooker.")
  arch-db         $(gettext "Create host arch packages DB.")
  note|-n         $(gettext "Add a note to the cooknotes.")
  notes|-ns       $(gettext "Display all the cooknotes.")
  block|-b        $(gettext "Block a package so cook will skip it.")
  unblock|-ub     $(gettext "Unblock a blocked package.")
  pkg|-p          $(gettext "Same as 'cook pkg' but with cooker log.")
  flavor|-f       $(gettext "Cook all packages of a flavor.")
  list|-l         $(gettext "Cook all packages in the given list.")
  cat|-c          $(gettext "Cook all packages of a category.")
  rev|-r          $(gettext "Cook packages of a specific revision.")
  all|-a          $(gettext "Find and cook all unbuilt packages.")

EOT
	exit 0
}

# Some messages occur in activity but log verbose output when checking for commits
# into a log file.
log_commits() {
	sed '/^.\//'d | sed '/^.hg/'d | tee -a $LOGS/commits.log
}

# Clean up before exit when check and cook commits finish.
clean_exit() {
	rm -f $command && touch $command
	rm -f $pidfile
}

# Summary for commits.
commits_summary() {
	msg="from revision $cur to $new"
	[ "$new" == "$cur" ] && msg="revision $new"
	echo "Will cook $msg"
	separator
	echo -e "\nSummary for commits"
	separator
	echo "Hg wok revision  : $cur"
	echo "Pulled revision  : $new"
	echo "Check date       : $(date '+%Y-%m-%d %H:%M:%S')"
}

# Scan packages build deps and fill up cookorder list.
cook_order_scan() {
	rm -f $cookorder
	touch $cookorder
	for pkg in $(cat $cooklist)
	do
		unset WANTED BUILD_DEPENDS BDEPS
		. $WOK/$pkg/receipt
		# The :: is for web interface color.
		if [ "$AUTO_DEP" -a ! "$WANTED" ]; then
			BDEPS=$(scan $PACKAGE --look_for=bdep --with_dev | \
				grep -v $(for i in $(look_for_rwanted) $PACKAGE; do echo " -e ^$i$"; done))
		else
			BDEPS="$BUILD_DEPENDS"
		fi
		[ "$WANTED$BDEPS" ] && echo "$pkg :: $WANTED $BDEPS"
		for dep in $BDEPS
		do
			if grep -q "^$dep$" $cooklist; then
				if ! grep -q "^$dep$" $cookorder; then
					echo "$dep" >> $cookorder
				fi
			fi
		done
	done

	# Append unordered packages to cookorder.
	for pkg in $(cat $cooklist)
	do
		if ! grep -q "^$pkg$" $cookorder; then
			echo "$pkg" >> $cookorder
		fi
	done
}

# Scan and rescan until the cooklist is ordered then handle WANTED.
cook_order() {
	time=$(date +%s)
	scan=0

	# Keep an original cooklist so we do a diff when ordering is finished.
	cp -f $cooklist $cooklist.0
	echo "cookorder" > $command
	echo -e "\nInitial Cooker order scan"
	separator
	
	if [ "$COMMAND" = "pkg" ]; then
		if ! grep -q "^$pkg$" $cooklist; then
			if [ -f "$WOK/$pkg/receipt" ]; then
				echo "$pkg" > $cooklist
			fi
		fi
	fi
	
	cook_order_scan

	# Diff between the cooklist and new ordered list ? So copy the last
	# cookorder to cooklist and rescan it.
	while /bin/true
	do
		diff $cooklist $cookorder > $cookorder.diff
		if [ -s "$cookorder.diff" ]; then
			scan=$(($scan + 1))
			echo -e "\nDiff scan: $scan"
			separator
			mv -f $cookorder $cooklist
			cook_order_scan
		else
			break
		fi
	done

	if [ "$COOK_WANTED" ]; then
		PACKAGE=$pkg
		for i in $PACKAGE $(look_for_rwanted); do
			if ! grep -q "^${i}$" $cooklist; then
				echo $i >> $cooklist
			fi
		done
	fi

	# Keep a diff between submited cooklist and the ordered.
	diff $cooklist.0 $cooklist > $cooklist.diff
	rm -f $cookorder $cookorder.diff $cooklist.0

	# Scan finished: append pkg to WANTED or leave it in the ordered cooklist.
	# TODO: grep the line number to get pkg position and keep it higher.
	echo -e "\nHandle WANTED package"
	separator
	for pkg in $(cat $cooklist)
	do
		unset WANTED
		. $WOK/$pkg/receipt
		if [ "$WANTED" ]; then
			echo "$pkg :: $WANTED"
			if grep -q ^${WANTED}$ $cooklist; then
				sed -i -e "/^$pkg$/"d  \
					-e "/^$WANTED$/ a $pkg" $cooklist
			fi
		fi
	done

	# Show ordered cooklist
	echo -e "\nCooklist order"
	separator
	cat $cooklist
	separator
	time=$(($(date +%s) - $time))
	pkgs=$(cat $cooklist | wc -l)
	echo -e "\nSummary for cookorder"
	separator
	cat << EOT
Ordered packages : $pkgs
Scans executed   : $scan
Scan duration    : ${time}s
EOT
	separator && rm -f $command
}

# Use in default mode and with all cmd.
cook_commits() {
	if [ -s "$commits" ]; then
		for pkg in $(cat $commits)
		do
			echo "cook:$pkg" > $command
			cook $pkg || broken
			sed -i /^${pkg}$/d $commits
			if [ "$COOK_WANTED" ]; then
				PACKAGE=$pkg
				for pkg in $(look_for_rwanted); do
					if ! grep -q "^$pkg$" $commits; then
						[ -f "$WOK/$pkg/receipt" ] || continue
						echo "cook:$pkg" > $command
						cook $pkg
					fi
				done
			fi
		done
	fi
}

# Cook all packages in a cooklist.
cook_list() {
	for pkg in $(cat $cooklist)
	do
		cook $pkg || broken
		sed -i /^${pkg}$/d $cooklist
		if [ "$COOK_WANTED" ]; then
			PACKAGE=$pkg
			for wpkg in $(look_for_rwanted); do
				if ! grep -q "^$wpkg$" $cooklist; then
					if [ -f "$WOK/$wpkg/receipt" ]; then
						cook $wpkg
						sed -i /^${wpkg}$/d $cooklist
					fi
				fi
			done
		fi
		if [ "$1" = "--list" ]; then
			pkgdb incoming
		fi
	done
}

# reverse pkg build when doing a big update to 
# rebuild all packages that depends on it
reverse_cook_list() {
	local pkg="$1"
	[ ! -f "$WOK/$pkg/receipt" ] && echo -e "\nNo package $pkg found.\n" && exit 0
	cp -a $cooklist $cooklist.bak
	rm -f $cooklist && touch $cooklist
	echo -e "\nReverse cooklist for: $pkg"
	separator && cd $WOK
	for rev in *
	do
		[ -f $WOK/$rev/receipt ] || continue
		unset DEPENDS BUILD_DEPENDS && . $WOK/$rev/receipt
		if echo "$DEPENDS $BUILD_DEPENDS" | fgrep -q $pkg; then
			echo "$rev" | tee -a $cooklist
		fi
	done && separator
	echo -e "Reverse dependencies found: $(cat $cooklist | wc -l)\n"
	strip_blocked
	cook_order | tee $LOGS/cookorder.log
	cook_list
}

# Create a arch.$ARCH file for each package cooked for the target host
# architecture
#
# The deal: we dont want all packages handled by cooker commands and stats,
# since we dont cross compile all packages for each arch but only a set of
# packages to provide one full featured desktop, servers and goodies useful
# for the host system.
#
arch_db() {
	count=0
	echo "Cleaning packages DB : arch.$ARCH"
	rm -f $wok/*/arch.$ARCH && cd $wok
	echo "Creating $ARCH packages DB..."
	for pkg in *
	do
		unset HOST_ARCH
		. $wok/$pkg/receipt
		#: ${HOST_ARCH=i486}
		if $(echo "$HOST_ARCH" | fgrep -q $ARCH); then
			count=$(($count + 1))
			echo "Adding: $pkg"
			touch $pkg/arch.$ARCH
		fi
	done
	echo "Packages for $ARCH : $count"
}


#
# Commands
#
case "$COMMAND" in
	usage|help|-u|-h)
		usage ;;
	setup|-s)
		# Setup the Cooker environment.
		echo -e "\nSetting up the Cooker"
		echo "Cooker setup using: $SLITAZ" | log
		separator
		echo "$PKGS" > $LOCALSTATE/mirror
		mkdir -p $LOCALSTATE/undigest/incoming
		echo "$INCOMING" > $LOCALSTATE/undigest/incoming/mirror
		echo "incoming" > $LOCALSTATE/priority
		tazpkg recharge
		for pkg in $INSTALL_PKGS
		do
			[ ! -f "$INSTALLED/$pkg/receipt" ] && tazpkg get-install $pkg
		done
		ls -1 "$INSTALLED" > $CACHE/chroot-pkgs
		mkdir -p $SLITAZ && cd $SLITAZ
		[ -d "$WOKHG" ] || hg clone $WOK_URL $WOKHG
		rsync_wok
		init_db_files
		cook gen-wok-db
		echo "Make unbuild list"
		cook unbuild --full
		[ "$AUTO_PURGE_SRC" ] && cook gen-src $SRC
		#[ -d "$FLAVORS" ] || hg clone $FLAVORS_URL flavors
		separator && newline ;;
	arch-db)
		# Manually create arch packages DB.
		arch_db ;;
	setup-cron)
		# Create cron job for the cooker.
		[ "$2" ] || hours=2
		if [ ! -f "$crontabs" ]; then
			mkdir -p /var/spool/cron/crontabs
		fi
		if ! fgrep -q /usr/bin/cooker $crontabs; then
			echo "# Run SliTaz Cooker every $hours hours" > $crontabs
			echo "0 */$hours * * *  /usr/bin/cooker --output=html" >> $crontabs
			killall crond 2>/dev/null && /etc/init.d/crond start
		fi ;;
	check-cron)
		[ -f "$crontabs" ] || \
			echo "There is no $crontabs here. Use setup-cron option." && exit 1
		fgrep /usr/bin/cooker $crontabs ;;
	note|-n)
		# Blocked a pkg and want others to know why ? Post a note!
		note="$2"
		date=$(date "+%Y-%m-%d %H:%M")
		[ "$note" ] && echo "$date : $note" >> $cooknotes ;;
	notes|-ns)
		# View cooknotes.
		echo -e "\nCooknotes"
		separator
		cat $cooknotes
		separator && newline ;;
	block|-b)
		# Block a package.
		[ "$pkg" ] && cook $pkg --block ;;
	unblock|-ub)
		# Unblock a package.
		[ "$pkg" ] && cook $pkg --unblock ;;
	reverse|-r)
		# Cook all reverse dependencies for a package. This command lets us
		# control the Cooker manually for commits that will cook a lot of packages.
		#
		# Use hg commit ? Ex: hg commit -m "Message bla bla | cooker:reverse"
		#
		reverse_cook_list $pkg ;;
	chroot)
		[ -d $SLITAZ/chroot ] || tazdev gen-chroot $2
		[ -d $SLITAZ/chroot ] && tazdev chroot $2
		;;
	toolchain)
		toolchain=$CACHE/toolchain
		[ -f $PKGS/fullco.txt ] || cook gen-wok-db
		cook gen-cooklist toolchain > $toolchain
		newline > $cooklist
		echo "cooker:toolchain" > $command
		echo "First build slitaz-toolchain"
		[ -f $blocked ] && rm -f $blocked
		touch $blocked
		cook slitaz-toolchain
		SKIP="glibc gcc binutils linux-api-headers slitaz-toolchain cookutils"
		for i in $SKIP; do
			echo "$i" >> $blocked
		done
		for pkg in $(cat $blocked)
		do
			sed -i /^${pkg}$/d $toolchain
		done && sed -i /^$/d $toolchain
		for pkg in $(cat $toolchain)
		do
			[ -f "$WOK/$pkg/receipt" ] || continue
			cook $pkg
			sed -i /^${pkg}$/d $toolchain
			if [ "$COOK_WANTED" ]; then
				PACKAGE=$pkg
				for pkg in $(look_for_rwanted); do
					if ! grep -q "^$pkg$" $toolchain; then
						[ -f "$WOK/$pkg/receipt" ] || continue
						cook $pkg
					fi
				done
			fi
			cook pkgdb incoming
		done
		[ -f $toolchain ] && rm -f $toolchain
		clean_exit ;;
	pkg|-p)
		# Same as 'cook pkg' but with log for web interface.
		[ ! -f "$WOK/$pkg/receipt" ] && echo "$pkg doesn't exist in wok" && exit 1
		if [ "$COOK_WANTED" ]; then
			PACKAGE=$pkg
			strip_blocked
			cook_order | tee $LOGS/cookorder.log
			cook_list
			if [ "$AUTO_UPDATE_DB" ]; then
				cook pkgdb $INCOMING
			fi
		else
			cook $pkg
		fi
		clean_exit ;;
	cat|-c)
		# Cook all packages of a category.
		cat="$2"
		cp -a $cooklist $cooklist.bak
		rm -f $cooklist && touch $cooklist && cd $WOK
		for pkg in *
		do
			unset CATEGORY && . $pkg/receipt
			[ "$CATEGORY" == "$cat" ] && echo $pkg >> $cooklist
		done
		strip_blocked
		cook_order | tee $LOGS/cookorder.log
		cook_list --list ;;
	flavor|-f)
		# Cook all packages of a flavor.
		name="$2"
		[ ! -d "$FLAVORS/$name" ] && \
			echo -e "\nSpecified flavor does not exist: $name\n" && exit 1
		[ -d "$FLAVORS/.hg" ] && cd $FLAVORS && hg pull -u
		list=$FLAVORS/$name/packages.list
		cp -a $list $cooklist
		strip_blocked
		cook_order | tee $LOGS/cookorder.log
		cook_list ;;
	list|-l)
		# Cook a list of packages given in argument.
		list="$cooklist"
		[ "$2" ] && list="$2"
		[ -f "$list" ] || $(gettext -e "$list doesn't exist." && exit 1)
		if [ "$list" != "$cooklist" ]; then
			cp -a $list $cooklist
		fi
		unset pkg
		strip_blocked
		if [ "$UPCOOKLIST" ]; then
			gen_cook_list
		else
			cook_order | tee $LOGS/cookorder.log
		fi
		cook_list --list
		cook pkgdb $INCOMING ;;
	rev|-r)
		# Cook or recook a specific Hg revision.
		rev="$2"
		[ "$rev" ] || exit 0
		cd $WOK
		cp -a $cooklist $cooklist.bak
		rm -f $cooklist && touch $cooklist
		for pkg in $(hg log --rev=$rev --template "{files}")
		do
			echo "$pkg" | cut -d "/" -f 1 >> $cooklist
		done
		strip_blocked
		cook_order | tee $LOGS/cookorder.log
		cook_list ;;
	all|-a)
		# Try to build all unbuilt packages except blocked's.
		echo "cooker:all" > $command
		cp -a $cooklist $cooklist.bak
		rm -f $cooklist && touch $cooklist
		newline && cd $WOK
		echo "Cooker cooklist"
		separator
		
		cook unbuild
		cp -a $unbuild $cooklist
		strip_blocked
		echo "Packages to cook: $(cat $cooklist | wc -l)" | log
		cook_list ;;
	new|pkgdb|get-src|check-incoming|gen-wok-db|upwok)
		cook "$COMMAND" "$2" "$3" "$4" "$5" ;;
	*)
		# Default is to cook all commits if not yet running.
		[ "$COMMAND" ] && usage
		cooklist=$commits
		if [ -f "$pidfile" ]; then
			pid=$(cat $pidfile)
			if [ -s /proc/$pid/status ]; then
				gettext -e "\nStill cooking latest commits with pid:"
				echo -e " $pid\n" && exit 0
			fi
			rm -f "$pidfile"
		fi

		# Start and get a PID file.
		rm -f $LOGS/commits.log
		newline
		echo "Checking for commits" | log_commits
		separator | tee -a $LOGS/commits.log

		echo $$ > $pidfile
		trap 'echo -e "\nCooker stopped: PID $$\n" && \
			rm -f $pidfile $command && exit 1' INT TERM

		echo "Cooker PID   : $$" | log_commits
		echo "Cooker date  : $(date '+%Y-%m-%d %H:%M:%S')" | log_commits

		# Get revisions. Here we have 2 echoes since we want a msg on screen,
		# in commits log and activity DB without a space before.
		cd $WOK || exit 1
		branch=$(cat /etc/slitaz-release)
		cur=$(hg head $branch --template '{rev}\n')
		echo "Updating wok : $WOKHG (rev $cur)" | log_commits
		echo "Updating wok: $WOKHG" | log
		echo "hg:pull" > $command
		cd $WOKHG && hg pull -u | log_commits
		new=$(hg head $branch --template '{rev}\n')
		# Store last rev to be used by CGI so it doesn't need to call hg head
		# on each load.
		echo "$new" > $wokrev

		# Sync build wok with rsync so we don't take care about removing old
		# files as before.
		if [ "$new" -gt "$cur" ]; then
			echo "Changes found from: $cur to $new" | log
			echo "Syncing build wok with Hg wok..." | log_commits
			rsync -r -t -c -l -u -v -D -E $WOKHG/ $WOK/ | \
				sed '/^$/'d | log_commits
		else
			echo "No revision changes: $cur vs $new" | log
			separator | log_commits
			clean_exit && newline && exit 0
		fi

		# Get and display modifications.
		cd $WOKHG
		commits_summary | log_commits
		cur=$(($cur + 1))
		rm -f $commits.tmp && touch $commits.tmp
		for rev in $(seq $cur $new)
		do
			for file in $(hg log --rev=$rev --template "{files}")
			do
				pkg=$(echo $file | cut -d "/" -f 1)
				desc=$(hg log --rev=$rev --template "{desc}" $file)
				echo "Commited package : $pkg - $desc" | log_commits
				echo $pkg >> $commits.tmp
			done
		done

		# We may have deleted packages and files in stuff/. Remove it and
		# clean DB as well as log file.
		cd $WOK
		for pkg in *
		do
			if [ ! -d "$WOKHG/$pkg" ]; then
				echo "Removing package: $pkg" | log_commits
				. $WOK/$pkg/receipt
				if [ -f "$INCOMING/$PACKAGE-$VERSION*" ]; then
					rm -rf $INCOMING/$PACKAGE-$VERSION*
				fi
				if [ -f "$PKGS/$PACKAGE-$VERSION*" ]; then
					rm -rf $PKGS/$PACKAGE-$VERSION*
				fi
				rm -rf $WOK/$pkg $LOGS/$pkg.log
				sed -i "/^${pkg}$/"d $blocked $broken $commits.tmp
			fi
		done

		# Keep previous commit and discard duplicate lines
		cat $commits $commits.tmp | sed /"^$"/d > $commits.new
		uniq $commits.new > $commits && rm $commits.*

		# Handle cross compilation. Create arch packages DB and remove pkgs
		# not cooked for this arch from the commits list.
		case "$ARCH" in
			arm)
				arch_db | log_commits
				for pkg in $(cat $commits)
				do
					if [ ! -f "$wok/$pkg/arch.$ARCH" ]; then
						echo "Cooker arch : skip $pkg (not included in: $ARCH)" | \
							log_commits
						sed -i "/^${pkg}$/"d $commits
					fi
				done ;;
			i486)
				echo "Cooker arch : $ARCH (default)" | log_commits ;;
			*)
				echo "Cooker arch : $ARCH" | log_commits ;;
		esac

		# Stats
		pkgs=$(cat $commits | wc -l)
		echo "Packages to cook: $pkgs" | log
		echo "Packages to cook : $pkgs" | log_commits
		separator | log_commits
		newline
		strip_blocked
		cook_order | tee $LOGS/cookorder.log
		cook_commits
		pkgdb $INCOMING
		clean_exit ;;
esac

exit 0
