#!/bin/sh
#
# Cross - Help build a cross toolchain on SliTaz.
#
# Copyright 2012 (C) SliTaz GNU/Linux - BSD License
# Author: Christophe Lincoln <pankso@slitaz.org>
#
. /lib/libtaz.sh

[ -f "/etc/slitaz/cross.conf" ] && . /etc/slitaz/cross.conf
[ -f "cross.conf" ] && . ./cross.conf

# Handle --config=/path/to/cross.conf
[ "$config" ] && . $config
source=$WORK/source
logdir=$WORK/log
install=$WORK/install

# Help and usage.
usage() {
	cat << EOT

Usage: $(basename $0) command --option

Commands:
  howto           Man alike and howto
  info            Display cross-tools info
  testsuite       Execute a small testsuite
  check           Check build host environment
  download        Download necessary sources
  show-log        Show a compile log
  binutils        Compile Binutils
  linux-headers   Install Kernel headers
  gcc-static      Compile GCC static
  glibc           Compile GNU Glibc
  gcc-final       Compile final GCC
  busybox         Cross compile Busybox
  compile         Compile everything at once
  clean           Clean-up build environment
  clean-tools     Clean: $PREFIX
  gen-prebuilt    Create an prebuilt toolchain archive

EOT
}

# Prebuilt README
prebuilt_readme() {
	echo -n "Creating toolchain README..."
	cat >> $package/README << EOT

SliTaz Prebuilt $ARCH cross toolchain
================================================================================
Move this $ARCH cross compilation toolchain to /usr/cross then add tools
to your PATH environment and test the toolchain:

	# mv $ARCH /usr/cross
	# export PATH=\$PATH:/usr/cross/$ARCH/bin

	# echo 'int main() { return 0; }' > test.c
	# $TARGET-gcc -v -o test.out test.c
	# readelf -h test.out

================================================================================

EOT
	status
}

# Make sure we have all directories.
init_compile() {
	export LC_ALL=POSIX LANG=POSIX
	[ "$SYSROOT" ] || export PATH=$PATH:$PREFIX/bin
	export CROSS_COMPILE=${TARGET}-
	mkdir -p $source $logdir $install
	cd $source
}

# Get source if not yet in $SRC.
download_src() {
	mkdir -p $SRC && cd $SRC
	[ -f "$BINUTILS_TARBALL" ] || wget $BINUTILS_WGET
	[ -f "$LINUX_TARBALL" ] || wget $LINUX_WGET
	[ -f "$GLIBC_TARBALL" ] || wget $GLIBC_WGET
	[ -f "$GCC_TARBALL" ] || wget $GCC_WGET
	[ -f "$BUSYBOX_TARBALL" ] || wget $BUSYBOX_WGET
}

# Use sysroot or not ?
check_sysroot() {
	if [ "$SYSROOT" ]; then
		PREFIX=/usr
		HDR_PATH=$SYSROOT/usr
		sysroot="--with-sysroot=$SYSROOT"
		echo "Configure: $sysroot"
	else
		HDR_PATH=$PREFIX/usr
	fi
}

# Work around to fix GCC include search path
#
# GCC include search path is: $PREFIX/$TARGET/include, so make sure it
# is a symlink to default: $PREFIX/usr/include
#
# Glibc install headers in: $PREFIX/include, move them to usr/include
# if needed. After when we cross compile packages with cook we have
# to install build dependencies using --root=$CROSS_PREFIX and so
# default include dir is: $PREFIX/usr/include ($PREFIX is the root
# of our cross environment.
#
check_include() {
	cd $PREFIX
	echo "Checking: $PREFIX"
	if ! readlink include >/dev/null; then
		echo "Creating symlink: usr/include include"
		cp -a include usr && rm -rf include
		ln -s usr/include include
	fi
	cd $PREFIX/$TARGET
	echo "Checking: $PREFIX/$TARGET"
	if ! readlink include >/dev/null; then
		echo "Creating symlink: ../usr/include include"
		cp -a include ../usr && rm -rf include
		ln -s ../usr/include include
	fi
	if ! readlink lib >/dev/null; then
		echo "Creating symlink: ../lib lib"
		rm -rf lib && ln -s ../lib lib
	fi
}

# 1. Binutils
binutils() {
	init_compile
	rm -rf binutils-$BINUTILS_VERSION
	echo "Extracting: $BINUTILS_TARBALL"
	tar xjf $SRC/$BINUTILS_TARBALL
	: ${BINUTILS_ARGS=--enable-shared}
	echo "Configure: $BINUTILS_ARGS"
	check_sysroot
	cd binutils-$BINUTILS_VERSION
	./configure \
		--prefix=$PREFIX \
		--target=$TARGET \
		--enable-targets=$BUILD_SYSTEM \
		$BINUTILS_ARGS $sysroot
	make || exit 1
	make install
	echo "cross: binutils compiled on: $(date)"
}

# 2. Kernel headers could use CROSS_COMPILE but gcc is not yet build.
# NOTE: Compile GCC static first then linux-headers ?
linux_headers() {
	init_compile
	echo "Extracting: $LINUX_TARBALL"
	tar xjf $SRC/$LINUX_TARBALL
	check_sysroot
	cd linux-$LINUX_VERSION
	make mrproper
	make ARCH=$ARCH headers_check
	make ARCH=$ARCH headers_install INSTALL_HDR_PATH=$HDR_PATH
}

# 3. GCC static (first pass)
gcc_static() {
	init_compile
	echo "Extracting: $GCC_TARBALL"
	tar xjf $SRC/$GCC_TARBALL
	echo "Configure: $GCC_STATIC_ARGS"
	check_sysroot
	# Arch fixes and work around
	case "$ARCH" in
		x86_64)
			# GCC wants Glib headers in cross environment (not tested
			# with sysroot) Should we install glibc-headers before ?
			[ "$SYSROOT" ] || \
				ln -s /usr/include $PREFIX/$TARGET/include ;;
	esac
	rm -rf gcc-static
	mkdir gcc-static && cd gcc-static
	../gcc-$GCC_VERSION/configure \
		--prefix=$PREFIX \
		--libexec=$PREFIX/lib \
		--target=$TARGET \
		--disable-shared \
		--disable-threads \
		--without-headers \
		--with-newlib \
		$GCC_STATIC_ARGS $sysroot
	make all-gcc all-target-libgcc || exit 1
	make install-gcc install-target-libgcc
	cd $PREFIX/lib/gcc/$TARGET/$GCC_VERSION
	echo "Creating symlink for static libgcc: libgcc_eh.a"
	rm -f libgcc_eh.a
	ln -s libgcc.a libgcc_eh.a
	echo "cross: gcc-static compiled on: $(date)"
}

# 4. GNU Glibc
glibc() {
	init_compile
	echo "Extracting: $GLIBC_TARBALL"
	tar xjf $SRC/$GLIBC_TARBALL
	echo "Configure: $GLIBC_ARGS"
	[ "$continue" ] || rm -rf glibc-build
	# Some arch may need glibc-ports and custom CFLAGS
	case "$ARCH" in
		arm)
			#export CFLAGS="-march=armv6 -mtune=generic -g -O2"
			[ -f "$SRC/glibc-ports-$GLIBC_VERSION.tar.bz2" ] || wget \
				http://ftp.gnu.org/gnu/libc/glibc-ports-$GLIBC_VERSION.tar.bz2 \
				-O $SRC/glibc-ports-$GLIBC_VERSION.tar.bz2 || exit 1
			echo "Extracting: glibc-ports-$GLIBC_VERSION.tar.bz2"
			rm -rf glibc-$GLIBC_VERSION/ports
			tar xjf $SRC/glibc-ports-$GLIBC_VERSION.tar.bz2
			mv glibc-ports-$GLIBC_VERSION glibc-$GLIBC_VERSION/ports ;;
		x86_64)
			ccflags="-m64" ;;
	esac
	echo "CFLAGS: $CFLAGS"
	mkdir -p glibc-build && cd glibc-build
	BUILD_CC="gcc" \
	CC="${TARGET}-gcc $ccflags" \
	libc_cv_forced_unwind=yes \
	libc_cv_c_cleanup=yes \
	../glibc-$GLIBC_VERSION/configure \
		--prefix=$PREFIX \
		--libexec=$PREFIX/lib/glibc \
		--host=$TARGET \
		--with-headers=$PREFIX/usr/include \
		--with-binutils=$PREFIX/bin \
		--enable-kernel=2.6.32 \
		$GLIBC_ARGS
	make || exit 1
	make install
	# Work around to let GCC find Glibc headers.
	if [ "$SYSROOT" ]; then
		cd $SYSROOT
		ln -s usr/include sys-include
	else
		check_include
	fi
	unset CFLAGS
	echo "cross: glibc compiled on: $(date)"
}

# 5. GCC final
gcc_final() {
	init_compile
	if [ ! -d "gcc-$GCC_VERSION" ]; then
		echo "Extracting: $GCC_TARBALL"
		tar xjf $SRC/$GCC_TARBALL
	fi
	echo "Configure: $GCC_FINAL_ARGS"
	check_sysroot
	[ "$continue" ] || rm -rf gcc-build
	mkdir -p gcc-build && cd gcc-build
	../gcc-$GCC_VERSION/configure \
		--prefix=$PREFIX \
		--libexec=$PREFIX/lib \
		--target=$TARGET \
		--enable-shared \
		--enable-c99 \
		--enable-long-long \
		--enable-__cxa_atexit \
		--with-pkgversion="SliTaz" \
		$GCC_FINAL_ARGS $sysroot
	make || exit 1
	make install &&
	echo "cross: GCC final compiled on: $(date)"
}

# Build Busybox to we can create prebuilt tiny rootfs image and boot
# from NFS ?
cross_busybox() {
	init_compile
	echo "Extracting: $BUSYBOX_TARBALL"
	tar xjf $SRC/$BUSYBOX_TARBALL
	cd busybox-$BUSYBOX_VERSION
	# CROSS_COMPILE is exported via init_compile.
	make defconfig
	make || exit 1
	make install
	chmod 4755 _install/bin/busybox
	readelf -h _install/bin/busybox
	echo "cross: busybox install path: $(pwd)/_install"
	echo "cross: busybox compiled on: $(date)"
}

#
# Commands
#

case "$1" in
	howto|man)
		doc=/usr/share/doc/cookutils/cross.txt
		[ -f "$doc" ] && less -E $doc ;;
	info)
		init_compile
		CC=${TARGET}-gcc
		echo -e "\nCross Toolchain information" && separator
		[ "$config" ] && echo "Config file     : $config"
		cat << EOT
Target arch     : $ARCH
C Compiler      : $CC
Build directory : $WORK
EOT
		if [ "$SYSROOT" ]; then
			PREFIX=/usr
			echo "Arch sysroot    : $SYSROOT"
		else
			echo "Additional path : $PREFIX/bin"
		fi
		separator && echo ""
		echo "GCC version" && separator
		if [ -x "$PREFIX/bin/$CC" ]; then
			$CC -v
		else
			echo "No C compiler. To build a toolchain run: cross compile"
		fi
		separator && echo "" ;;
	testsuite)
		init_compile
		echo "[COMPILING] $TARGET-gcc -v -Wall -o test.out test.c" \
			| tee $logdir/testsuite.log
		echo 'int main() { return 0; }' > test.c
		$TARGET-gcc -v -Wall -o test.out test.c 2>&1 | tee -a $logdir/testsuite.log
		if [ -x /usr/bin/file ]; then
			echo -e "\n[CHECKING] file test.out" | tee -a $logdir/testsuite.log
			file test.out | tee -a $logdir/testsuite.log
		fi
		echo -e "\n[CHECKING] readelf -h test.out" | tee -a $logdir/testsuite.log
		readelf -h test.out | tee -a $logdir/testsuite.log ;;
	check)
		echo "Checking: build system packages"
		for pkg in slitaz-toolchain mpfr mpfr-dev gmp gmp-dev mpc-library \
			gawk autoconf; do
			if [ ! -d "/var/lib/tazpkg/installed/$pkg" ]; then
				echo "Missing packages: $pkg"
				if [ -x /usr/sbin/spk-add ]; then
					spk-add $pkg
				else
					tazpkg -gi $pkg
				fi
			fi
		done
		# See: check_include()
		if [ "$SYSROOT" ]; then
			echo "Using: --with-sysroot=$SYSROOT"
			echo "WARNING: not well tested and buggy"
			exit 0
		fi
		check_include ;;
	download)
		download_src ;;
	show-log)
		pkg=$2
		log=$logdir/$pkg.log
		if [ ! -f "$log" ]; then
			echo "No log file found for: $pkg" && exit 1
		fi
		less -E $log ;;
	binutils)
		rm -f $logdir/binutils.log
		binutils 2>&1 | tee $logdir/binutils.log ;;
	gcc-static)
		gcc_static 2>&1 | tee $logdir/gcc-static.log ;;
	linux-headers)
		linux_headers 2>&1 | tee $logdir/linux-headers.log ;;
	glibc)
		glibc 2>&1 | tee $logdir/glibc.log ;;
	gcc-final)
		gcc_final 2>&1 | tee $logdir/gcc-final.log ;;
	busybox)
		cross_busybox 2>&1 | tee $logdir/busybox.log ;;
	compile)
		# Compile the full toolchain.
		time=$(date +%s)
		init_compile
		echo "Compile start: $(date)" | tee $logdir/compile.log
		download_src
		binutils 2>&1 | tee $logdir/binutils.log
		gcc_static 2>&1 | tee $logdir/gcc-static.log
		linux_headers 2>&1 | tee $logdir/linux-headers.log
		glibc 2>&1 | tee $logdir/glibc.log
		gcc_final 2>&1 | tee $logdir/gcc-final.log
		echo ""
		echo "Compile end  : $(date)" | tee -a $logdir/compile.log
		time=$(($(date +%s) - $time))
		sec=$time
		div=$(( ($time + 30) / 60))
		[ "$div" != 0 ] && min="~ ${div}m"
		echo "Build time   : ${sec}s $min" | tee -a $logdir/compile.log
		echo "" ;;
	clean)
		echo -n "Removing all source files..."
		rm -rf $WORK/source/* && status
		[ "$log" ] && rm -f $WORK/log/*.log
		echo "To clean chroot: rm -rf $PREFIX" ;;
	clean-tools)
		# Remove crap :-)
		init_compile
		echo "Cleaning   : $PREFIX ($(du -sh $PREFIX | awk '{print $1}'))"
		for dir in info man locale
		do
			echo -n "Removing   : $dir"
			rm -rf $PREFIX/share/$dir && status
		done
		rm -f $PREFIX/lib/*-gdb.py
		echo -n "Stripping  : shared libs and binaries"
		${TARGET}-strip -s $PREFIX/lib/*.so* 2>/dev/null
		${TARGET}-strip -s $PREFIX/bin/* 2>/dev/null
		${TARGET}-strip -s $PREFIX/${TARGET}/bin/* 2>/dev/null
		${TARGET}-strip -s $PREFIX/$TARGET/lib/gcc/$TARGET/*/cc1*
		${TARGET}-strip -s $PREFIX/$TARGET/lib/gcc/$TARGET/*/lto*
		sleep 1 && status
		echo -n "Tools size : " && du -sh $PREFIX | awk '{print $1}' ;;
	gen-rootfs)
		echo "Use arm packages: basefile, boot-scripts, busybox and glibc-base"
		echo "Install them in a rootfs: tazpkg *-arm.tazpkg --root=/my/rootfs" ;;
	gen-prebuilt)
		# Create a prebuilt cross toolchain tarball.
		init_compile
		date=$(date "+%Y%m%d")
		package="slitaz-cross-$ARCH-toolchain-$date"
		tarball="$package.tar.bz2"
		cd /usr/cross
		mkdir $package || exit 1
		echo ""
		echo -n "Copying $ARCH to: $package"
		cp -a $ARCH $package
		rm -rf $package/share $package/etc
		status
		prebuilt_readme
		echo -n "Creating prebuilt $ARCH toolchain tarball..."
		tar cjf $tarball $package
		status
		mv -f $tarball $WORK
		rm -rf $package
		size=$(du -sh $WORK/$tarball | awk '{print $1}')
		echo "Tarball path: $WORK/$tarball"
		echo "Tarball size: $size"
		echo "" ;;
	*)
		usage ;;
esac

