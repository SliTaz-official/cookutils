#!/bin/sh
#
# Cross - Help build a cross toolchain on SliTaz.
#
# Copyright 2012 (C) SliTaz GNU/Linux - BSD License
# Author: Christophe Lincoln <pankso@slitaz.org>
#
. /lib/libtaz.sh

[ -f "/etc/slitaz/cross.conf" ] && . /etc/slitaz/cross.conf
[ -f "cross.conf" ] && . ./cross.conf

# Handle --config=/path/to/cross.conf
[ "$config" ] && . $config
source=$WORK/source
logdir=$WORK/log
install=$WORK/install

# Help and usage.
usage() {
	cat << EOT

Usage: $(basename $0) command --option

Commands:
  howto           Man alike and howto
  info            Display cross-tools info
  testsuite       Execute a small testsuite
  check-env       Check build host tools
  download        Download necessary sources
  clean           Clean-up build environment
  clean-tools     Clean: $PREFIX
  show-log        Show a compile log
  binutils        Compile Binutils
  gcc-static      Compile GCC static
  linux-headers   Install Kernel headers
  glibc           Compile GNU Glibc
  gcc-final       Compile final GCC
  busybox         Cross compile Busybox
  compile         Compile everything at once

EOT
}

# Make sure we have all directories.
init_compile() {
	export LC_ALL=POSIX LANG=POSIX
	[ "$SYSROOT" ] || export PATH=$PATH:$PREFIX/bin
	export CROSS_COMPILE=${TARGET}-
	mkdir -p $source $logdir $install
	cd $source
}

# Get source if not yet in $SRC.
download_src() {
	mkdir -p $SRC && cd $SRC
	[ -f "binutils-$BINUTILS_VERSION.tar.bz2" ] || wget $BINUTILS_WGET
	[ -f "linux-$LINUX_VERSION.tar.bz2" ] || wget $LINUX_WGET
	[ -f "glibc-$GLIBC_VERSION.tar.bz2" ] || wget $GLIBC_WGET
	[ -f "gcc-$GCC_VERSION.tar.bz2" ] || wget $GCC_WGET
	[ -f "busybox-$BUSYBOX_VERSION.tar.bz2" ] || wget $BUSYBOX_WGET
}

# Use sysroot or not ?
check_sysroot() {
	if [ "$SYSROOT" ]; then
		PREFIX=/usr
		HDR_PATH=$SYSROOT/usr
		sysroot="--with-sysroot=$SYSROOT"
		echo "Configure : $sysroot"
	else
		HDR_PATH=$PREFIX
	fi
}

# 1. Binutils
binutils() {
	init_compile
	rm -rf binutils-$BINUTILS_VERSION
	echo "Extracting: binutils-$BINUTILS_VERSION.tar.bz2"
	tar xjf $SRC/binutils-$BINUTILS_VERSION.tar.bz2
	: ${BINUTILS_ARGS=--enable-shared}
	echo "Configure : $BINUTILS_ARGS"
	exit 1
	check_sysroot
	cd binutils-$BINUTILS_VERSION
	./configure \
		--prefix=$PREFIX \
		--target=$TARGET \
		--enable-targets=$BUILD_SYSTEM \
		$BINUTILS_ARGS $sysroot
	make || exit 1
	make install
	#echo "cross: binutils compiled on: $(date)"
}

# 2. GCC static (first pass)
gcc_static() {
	init_compile
	echo "Extracting: gcc-$GCC_VERSION.tar.bz2"
	tar xjf $SRC/gcc-$GCC_VERSION.tar.bz2
	echo "Configure : $GCC_STATIC_ARGS"
	check_sysroot
	# Arch fixes and work around
	case "$ARCH" in
		x86_64)
			# GCC wants Glib headers in cross environment (not tested
			# with sysroot) Should we install glibc-headers before ?
			[ "$SYSROOT" ] || \
				ln -s /usr/include $PREFIX/$TARGET/include ;;
	esac
	rm -rf gcc-static
	mkdir gcc-static && cd gcc-static
	../gcc-$GCC_VERSION/configure \
		--prefix=$PREFIX \
		--libexec=$PREFIX/lib \
		--target=$TARGET \
		--disable-shared \
		--disable-threads \
		--without-headers \
		--with-newlib \
		$GCC_STATIC_ARGS $sysroot
	make all-gcc all-target-libgcc || exit 1
	make install-gcc install-target-libgcc
	cd $PREFIX/lib/gcc/$TARGET/$GCC_VERSION
	echo "Creating symlink for static libgcc: libgcc_eh.a"
	rm -f libgcc_eh.a && ln -s libgcc.a libgcc_eh.a
}

# 3. Kernel headers use static GCC
linux_headers() {
	init_compile
	echo "Extracting: linux-$LINUX_VERSION.tar.bz2"
	tar xjf $SRC/linux-$LINUX_VERSION.tar.bz2
	check_sysroot
	cd linux-$LINUX_VERSION
	make mrproper
	make ARCH=$ARCH headers_check
	make ARCH=$ARCH headers_install \
		INSTALL_HDR_PATH=$HDR_PATH
}

# 4. GNU Glibc
glibc() {
	init_compile
	echo "Extracting: glibc-$GLIBC_VERSION.tar.bz2"
	tar xjf $SRC/glibc-$GLIBC_VERSION.tar.bz2
	echo "Configure : $GLIBC_ARGS"
	[ "$continue" ] || rm -rf glibc-build
	# Some arch may need glibc-ports and custom CFLAGS
	case "$ARCH" in
		arm)
			#export CFLAGS="-march=armv6 -mtune=generic -g -O2"
			[ -f "$SRC/glibc-ports-$GLIBC_VERSION.tar.bz2" ] || wget \
				http://ftp.gnu.org/gnu/libc/glibc-ports-$GLIBC_VERSION.tar.bz2 \
				-O $SRC/glibc-ports-$GLIBC_VERSION.tar.bz2 || exit 1
			echo "Extracting: glibc-ports-$GLIBC_VERSION.tar.bz2"
			rm -rf glibc-$GLIBC_VERSION/ports
			tar xjf $SRC/glibc-ports-$GLIBC_VERSION.tar.bz2
			mv glibc-ports-$GLIBC_VERSION glibc-$GLIBC_VERSION/ports ;;
	esac
	#echo "CFLAGS: $CFLAGS"
	mkdir -p glibc-build && cd glibc-build
	BUILD_CC="gcc" \
	CC="$PREFIX/bin/$TARGET-gcc" \
	libc_cv_forced_unwind=yes \
	libc_cv_c_cleanup=yes \
	../glibc-$GLIBC_VERSION/configure \
		--prefix=$PREFIX \
		--host=$TARGET \
		--with-headers=$PREFIX/include \
		--with-binutils=$PREFIX/bin \
		$GLIBC_ARGS
	make || exit 1
	make install
	# Work around to let GCC find Glibc headers.
	if [ "$SYSROOT" ]; then
		cd $SYSROOT
		ln -s usr/include sys-include
	else
		cd $PREFIX/$TARGET
		rm -rf lib include
		ln -s ../lib lib
		ln -s ../include include
	fi
	#unset CFLAGS
}

# 5. GCC final
gcc_final() {
	init_compile
	if [ ! -d "gcc-$GCC_VERSION" ]; then
		echo "Extracting: gcc-$GCC_VERSION.tar.bz2"
		tar xjf $SRC/gcc-$GCC_VERSION.tar.bz2
	fi
	echo "Configure : $GCC_FINAL_ARGS"
	check_sysroot
	rm -rf gcc-build
	mkdir gcc-build && cd gcc-build
	../gcc-$GCC_VERSION/configure \
		--prefix=$PREFIX \
		--libexec=$PREFIX/lib \
		--target=$TARGET \
		--enable-shared \
		--enable-c99 \
		--enable-long-long \
		--enable-__cxa_atexit \
		--with-pkgversion="SliTaz" \
		$GCC_FINAL_ARGS $sysroot
	make || exit 1
	make install
}

# Build Busybox to we can create prebuilt tiny rootfs image and boot
# from NFS ?
cross_busybox() {
	init_compile
	echo "Extracting: busybox-$BUSYBOX_VERSION.tar.bz2"
	tar xjf $SRC/busybox-$BUSYBOX_VERSION.tar.bz2
	cd busybox-$BUSYBOX_VERSION
	# CROSS_COMPILE is exported via init_compile.
	make defconfig
	make || exit 1
	make install
	chmod 4755 _install/bin/busybox
	readelf -h _install/bin/busybox
	echo "Busybox install path: $(pwd)/_install"
}

#
# Commands
#

case "$1" in
	howto|man)
		doc=/usr/share/doc/cookutils/cross.txt
		[ -f "$doc" ] && less -E $doc ;;
	info)
		init_compile
		CC=${TARGET}-gcc
		echo -e "\nCross Toolchain information" && separator
		[ "$config" ] && echo "Config file     : $config"
		cat << EOT
Target arch     : $ARCH
C Compiler      : $CC
Build directory : $WORK
EOT
		if [ "$SYSROOT" ]; then
			PREFIX=/usr
			echo "Arch sysroot    : $SYSROOT"
		else
			echo "Additional path : $PREFIX/bin"
		fi
		separator && echo ""
		echo "GCC version" && separator
		if [ -x "$PREFIX/bin/$CC" ]; then
			$CC -v
		else
			echo "No C compiler. To build a toolchain run: cross compile"
		fi
		separator && echo "" ;;
	testsuite)
		init_compile
		echo "[COMPILING] $TARGET-gcc -v -Wall -o test.out test.c" \
			| tee $logdir/testsuite.log
		echo 'int main() { return 0; }' > test.c
		$TARGET-gcc -v -Wall -o test.out test.c 2>&1 | tee -a $logdir/testsuite.log
		if [ -x /usr/bin/file ]; then
			echo -e "\n[CHECKING] file test.out" | tee -a $logdir/testsuite.log
			file test.out | tee -a $logdir/testsuite.log
		fi
		echo -e "\n[CHECKING] readelf -h test.out" | tee -a $logdir/testsuite.log
		readelf -h test.out | tee -a $logdir/testsuite.log ;;
	check-env)
		for pkg in mpfr mpfr-dev gmp gmp-dev mpc-library gawk autoconf
		do
			if [ ! -d "/var/lib/tazpkg/installed/$pkg" ]; then
				echo "Missing packages: $pkg"
				[ "$install" ] && tazpkg -gi $pkg
			fi
		done ;;
	download)
		download_src ;;
	clean)
		echo -n "Removing all source files..."
		rm -rf $WORK/source/* && status
		[ "$log" ] && rm -f $WORK/log/*.log
		echo "To clean chroot: rm -rf $PREFIX" ;;
	show-log)
		pkg=$2
		log=$logdir/$pkg.log
		if [ ! -f "$log" ]; then
			echo "No log file found for: $pkg" && exit 1
		fi
		less -E $log ;;
	binutils)
		rm -f $logdir/binutils.log
		binutils 2>&1 | tee $logdir/binutils.log ;;
	gcc-static)
		gcc_static 2>&1 | tee $logdir/gcc-static.log ;;
	linux-headers)
		linux_headers 2>&1 | tee $logdir/linux-headers.log ;;
	glibc)
		glibc 2>&1 | tee $logdir/glibc.log ;;
	gcc-final)
		gcc_final 2>&1 | tee $logdir/gcc-final.log ;;
	busybox)
		cross_busybox 2>&1 | tee $logdir/busybox.log ;;
	compile)
		# Compile the full toolchain.
		time=$(date +%s)
		init_compile
		echo "Compile start: $(date)" | tee $logdir/compile.log
		download_src
		binutils 2>&1 | tee $logdir/binutils.log
		gcc_static 2>&1 | tee $logdir/gcc-static.log
		linux_headers 2>&1 | tee $logdir/linux-headers.log
		glibc 2>&1 | tee $logdir/glibc.log
		gcc_final 2>&1 | tee $logdir/gcc-final.log
		echo ""
		echo "Compile end  : $(date)" | tee -a $logdir/compile.log
		time=$(($(date +%s) - $time))
		sec=$time
		div=$(( ($time + 30) / 60))
		[ "$div" != 0 ] && min="~ ${div}m"
		echo "Build time   : ${sec}s $min" | tee -a $logdir/compile.log
		echo "" ;;
	clean-tools)
		# Remove crap :-)
		init_compile
		echo "Cleaning  : $PREFIX"
		for dir in info man locale
		do
			echo -n "Removing  : $dir"
			rm -rf $PREFIX/share && status
		done
		echo -n "Stripping : binaries"
		for bin in $PREFIX/bin/${TARGET}-*
		do
			[ "$bin" == "$PREFIX/bin/${TARGET}-strip" ] && continue
			if [ -x "$bin" ]; then
				${TARGET}-strip -s $bin 2>/dev/null
			fi
		done && status
		echo -n "Tools size: " && du -sh $PREFIX | awk '{print $1}' ;;
	gen-rootfs)
		#
		# TESTING
		#
		# Create a bootable rootfs ? dd for an HD image ?
		init_compile
		rootfs=/tmp/cross/rootfs
		tarball="rootfs.tar.bz2"
		rm -rf $rootfs && mkdir -p $rootfs
		cd /tmp/cross
		echo -n "Installing SliTaz base files..."
		tar xzf $SRC/slitaz-base-files-5.2.tar.gz
		cp -a slitaz-base-files-*/rootfs/* $rootfs
		status
		echo -n "Installing Busybox..."
		cp -a $source/busybox-$BUSYBOX_VERSION/_install/* $rootfs
		status
		echo -n "Creating tarball: $tarball"
		tar cjf $tarball rootfs
		status
		echo -n "Moving rootfs to: $WORK"
		mv $tarball $WORK
		status
		du -sh $WORK/$tarball
		rm -rf /tmp/cross ;;
	*)
		usage ;;
esac

