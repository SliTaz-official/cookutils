#!/bin/sh
#
# Cook - A tool to cook and generate SliTaz packages. Read the README
# before adding or modifing any code in cook!
#
# Copyright (C) SliTaz GNU/Linux - GNU gpl v3
# Author: Christophe Lincoln <pankso@slitaz.org>
#
. /usr/lib/slitaz/libcook.sh
. /usr/lib/slitaz/libcookorder.sh

COMMAND="$1"

#
# Functions
#

usage() {
	cat << EOT

$(echo -e "\033[1m$(gettext "Usage:")\033[0m") cook [package|command] [list|--option]

$(echo -e "\033[1m$(gettext "Commands:")\033[0m")
  usage|help         $(gettext "Display this short usage.")
  setup              $(gettext "Setup your build environment.")
  *-setup            $(gettext "Setup a cross environment.")
  test               $(gettext "Test environment and cook a package.")
  list-wok           $(gettext "List packages in the wok.")
  search             $(gettext "Simple packages search function.")
  new                $(gettext "Create a new package with a receipt".)
  list               $(gettext "Cook a list of packages.")
  clean-wok          $(gettext "Clean-up all packages files.")
  clean-src          $(gettext "Clean-up all packages sources.")
  upwok              $(gettext "Update wok.")
  gen-wok-db         $(gettext "Build cook order files.")
  gen-src            $(gettext "Build source list.")
  check-incoming     $(gettext "Move incoming packages to packages folder.")
  gen-cooklist       $(gettext "Make cook order list.")
  check-src          $(gettext "Check upstream tarball for package in the wok.")
  maintainers        $(gettext "List all maintainers in the wok.")
  maintained-by      $(gettext "List packages maintained by a contributor.")
  tags               $(gettext "List all tags used in wok receipts.")
  pkgdb              $(gettext "Create packages DB lists and flavors.")
  unbuild            $(gettext "List all unbuild packages.")

$(echo -e "\033[1m$(gettext "Options:")\033[0m")
  --clean|-c         Cook    : $(gettext "clean the package in the wok.")
  --install|-i       Cook    : $(gettext "cook and install the package.")
  --getsrc|-gs       Cook    : $(gettext "get the package source tarball.")
  --block|-b         Cook    : $(gettext "Block a package so cook will skip it.")
  --unblock|-ub      Cook    : $(gettext "Unblock a blocked package.")
  --interactive|-x   New     : $(gettext "create a receipt interactively.")
  --local            Upwok   : $(gettext "update wok local changes in wok-hg.")
  --wok|-w           Setup   : $(gettext "clone the cooking wok from Hg repo.")
  --stable           Setup   : $(gettext "clone the stable wok from Hg repo.")
  --undigest         Setup   : $(gettext "clone the undigest wok from Hg repo.")
  --tiny             Setup: $(gettext "clone the tiny SliTaz wok from Hg repo.")
  --forced           Setup: $(gettext "force reinstall of chroot packages.")
  --flavors          Pkgdb   : $(gettext "create up-to-date flavors files.")
  --full             Unbuild : $(gettext "create a full unbuild list.")
  --list             Unbuild : $(gettext "Copy unbuild list into your cooklist.")

EOT
	exit 0
}

# We don't want these escapes in web interface.
clean_log() {
	sed -i -e s'|\[70G\[ \[1;32m| |' \
		-e s'|\[0;39m \]||' $LOGS/$pkg.log
}

if_empty_value() {
	if [ -z "$value" ]; then
		gettext "QA: empty variable:"; echo -e " ${var}=\"\"\n"
		exit 1
	fi
}

# QA: check a receipt consistency before building.
receipt_quality() {
	gettext -e "QA: checking package receipt...\n"
	unset online
	if ifconfig | grep -q -A 1 "^[a-z]*[0-9]" | fgrep 'addr:'; then
		online="online"
	fi
	for var in PACKAGE VERSION CATEGORY SHORT_DESC MAINTAINER WEB_SITE
	do
		unset value
		value="$(. $receipt ; eval echo \$$var)"
		case "$var" in
			PACKAGE|VERSION|SHORT_DESC)
				if_empty_value ;;
			CATEGORY)
				[ -z "$value" ] && value="empty"
				valid="$PKGS_CATEGORIES"
				if ! echo "$valid" | grep -q -w "$value"; then
					gettext "QA: unknown category:"; echo -e " $value\n"
					exit 1
				fi ;;
			WEB_SITE)
				# We don't check WGET_URL since if dl is needed it will fail.
				# Break also if we're not online. Here error is not fatal.
				if_empty_value
				[ -z "$online" ] || break
				case $value in
						https://*)
							if ! wget -T $TIMEOUT --spider --no-check-certificate $value 2>/dev/null; then
								gettext "QA: Unable to reach:"; echo -e " $value"
							fi ;;
						http://*|ftp://*)
							if ! busybox wget -T $TIMEOUT -s $value 2>/dev/null; then
								gettext "QA: Unable to reach:"; echo -e " $value"
							fi ;;
				esac
		esac
	done
}

# Paths used in receipt and by cook itself.
set_paths() {
	pkgdir=$WOK/$PACKAGE
	basesrc=$pkgdir/source
	tmpsrc=$basesrc/tmp
	src=$basesrc/$PACKAGE-$VERSION
	taz=$pkgdir/taz
	pack=$taz/$PACKAGE-${VERSION}${EXTRAVERSION}
	fs=$pack/fs
	stuff=$pkgdir/stuff
	install=$pkgdir/install
	pkgsrc="${SOURCE:-$PACKAGE}-${KBASEVER:-$VERSION}"
	lzma_tarball="$pkgsrc.tar.lzma"
	orig_tarball="$TARBALL"
	if [ "$PATCH" ]; then
		[ "${PTARBALL}" ] || PTARBALL="$(basename $PATCH)"
	fi
	if [ "$WANTED" ]; then
		basesrc=$WOK/$WANTED/source
		src=$basesrc/$WANTED-$VERSION
		install=$WOK/$WANTED/install
		wanted_stuff=$WOK/$WANTED/stuff
	fi
	if [ "$SOURCE" ]; then
		source_stuff=$WOK/$SOURCE/stuff
	fi
	# Kernel version is set from linux
	if [ -f "$WOK/linux/receipt" ]; then
		kvers=$(grep ^VERSION= $WOK/linux/receipt | cut -d '"' -f 2)
		kbasevers=${kvers:0:3}
	fi
	# Python version 
	if [ -f "$WOK/python/receipt" ]; then
		pyvers=$(grep ^VERSION= $WOK/python/receipt | cut -d '"' -f 2)
	fi
	# perl version for some packages needed it
	if [ -f "$WOK/perl/receipt" ]; then
		perlvers=$(grep ^VERSION= $WOK/perl/receipt | cut -d '"' -f 2)
	fi
	# Old way compatibility.
	_pkg=$install
}

# Create source tarball when URL is a SCM.
create_tarball() {
	local tarball
	tarball=$pkgsrc.tar.bz2
	[ "$LZMA_SRC" ] && tarball=$lzma_tarball
	gettext "Creating tarball: "; echo "$tarball"
	if [ "$LZMA_SRC" ]; then
		tar -c $pkgsrc | lzma e $SRC/$tarball -si $LZMA_SET_DIR || exit 1
		LZMA_SRC=""
	else
		tar cjf $tarball $pkgsrc || exit 1
		mv $tarball $SRC && rm -rf $pkgsrc
	fi
	TARBALL=$tarball
}

# Get package source. For SCM we are in cache so clone here and create a
# tarball here.
get_source() {
	pwd=$(pwd)
	for file in $@; do
		gettext "Getting source from url:"; echo " ${file#*|}"
		if [ "$file" = "$PATCH" -o "$file" = "$orig_url_patch" ]; then
			SAVE_FILE="$SRC/$PTARBALL"
		else
			SAVE_FILE="$SRC/$TARBALL"
		fi
		case "$file" in
			http://*|ftp://*)
				# Busybox Wget is better!
				busybox wget $WGET_OPTIONS -T $TIMEOUT -c -O $SAVE_FILE $file || \
					(echo -e "ERROR: wget $file" && exit 1) ;;
			https://*)
				wget $WGET_OPTIONS -T $TIMEOUT -c --no-check-certificate -O $SAVE_FILE $file || \
					(echo -e "ERROR: wget $file" && exit 1) ;;
			hg*|mercurial*)
				if $(echo "$file" | fgrep -q "hg|"); then
					url=${file#hg|}
				else
					url=${file#mercurial|}
				fi
				gettext -e "Getting source from Hg...\n"
				echo "URL: $url"
				gettext "Cloning to: "; echo "$pwd/$pkgsrc"
				if [ "$BRANCH" ]; then
					echo "Hg branch: $BRANCH"
					hg clone $url --rev $BRANCH $pkgsrc || \
						(echo "ERROR: hg clone $url --rev $BRANCH" && exit 1)
				else
					hg clone $url $pkgsrc || (echo "ERROR: hg clone $url" && exit 1)
				fi
				create_tarball ;;
			git*)
				url=${file#git|}
				gettext -e "Getting source from Git...\n"
				echo "URL: $url"
				git clone $url $pkgsrc || (echo "ERROR: git clone $url" && exit 1)
				if [ "$BRANCH" ]; then
					echo "Git branch: $BRANCH"
					cd $pkgsrc && git checkout $BRANCH && cd ..
				fi
				create_tarball ;;
			bzr*|bazaar*)
				if $(echo "$file" | fgrep -q "bzr|"); then
					url=${file#bzr|}
				else
					url=${file#bazaar|}
				fi
				gettext -e "Getting source from BZR...\n"
				echo "URL: $url"
				bzr branch $url $pkgsrc
				create_tarball ;;
			cvs*)
				url=${file#cvs|}
				mod=$PACKAGE
				[ "$CVS_MODULE" ] && mod=$CVS_MODULE
				gettext -e "Getting source from CVS...\n"
				echo "URL: $url"
				[ "$CVS_MODULE" ] && echo "CVS module: $mod"
				gettext "Cloning to: "; echo "$pwd/$mod"
				cvs -d:$url co $mod && mv $mod $pkgsrc
				create_tarball ;;
			svn*|subversion*)
				if $(echo "$file" | fgrep -q "svn|"); then
					url=${file#svn|}
				else
					url=${file#subversion|}
				fi
				gettext -e "Getting source from SVN...\n"
				echo "URL: $url"
				if [ "$BRANCH" ]; then
					echo t | svn co $url -r $BRANCH $pkgsrc
				else
					echo t | svn co $url $pkgsrc
				fi
				create_tarball ;;
			*)
				gettext -e "\nERROR: Unable to handle:"; echo -e " $file \n" | \
					tee -a $LOGS/$PACKAGE.log
				exit 1 ;;
		esac
	done
}

getsrc() {
	gettext "Getting source for:"; echo " $pkg"
	set_paths
	[ -f "$SRC/$lzma_tarball" ] && \
		TARBALL="$lzma_tarball"
	
	# Get source tarball and make sure we have source dir named:
	# $PACKAGE-$VERSION to be standard in receipts. Here we use tar.lzma
	# tarball if it exists.
	look_for_cookopt !unpack && unpack="no"
	look_for_cookopt !repack_src && LZMA_SRC=""
	if [ ! "$WANTED" ] && [ "$TARBALL" ] && [ ! "$unpack" ] && [ ! "$cook_code" ]; then
		[ -d $tmpsrc ] && rm -rf $tmpsrc
		mkdir -p $tmpsrc && cd $tmpsrc
	fi
	
	if [ "$WGET_URL" ] && [ ! -f "$SRC/$TARBALL" ]; then
		separator && download
	fi
	
	if [ "$WGET_URL" ] && [ -f "$SRC/$TARBALL" ] && [ ! "$unpack" ] && [ ! "$cook_code" ]; then
		[ "$TARBALL" = "$lzma_tarball" ] && LZMA_SRC=""
		if [ "$1" = "--extract" ]; then
			extract_source || exit 1
			if [ ! -f "$SRC/$lzma_tarball" ] && [ "$LZMA_SRC" ]; then
				echo -e "Repacking source."
				repack_source || exit 1
			fi
			extract_path || exit 1
			if [ -f $SRC/$TARBALL ]; then
				[ -d $tmpsrc ] && rm -rf $tmpsrc
			fi
		fi		
	fi
	
	# This is to make sure if PATCH equals something it will be downloaded
	# checks are done in download functions
	if [ "$PATCH" ] && [ ! "$cook_code" ]; then
		if [ ! -f "$SRC/$PTARBALL" ]; then
			separator && download
		fi
	fi
	
	echo -e "Tarball: $SRC/$TARBALL"
	[ "$PATCH" ] && echo -e "Patch: $SRC/$PTARBALL"
}

download_base() {
	local URLS url alt_url orig_url orig_url_patch
	url="$ONLINE_SRC_REPOSITORY"
	if [ "$SOURCE" ]; then
		alt_url="${url}${SOURCE:0:1}/$SOURCE-${KBASEVER:-$VERSION}.tar.lzma"
	else
		alt_url="${url}${PACKAGE:0:1}/$PACKAGE-${KBASEVER:-$VERSION}.tar.lzma"
	fi
	orig_url="${url}${TARBALL:0:1}/$TARBALL"
	[ "$PATCH" ] && orig_url_patch="${url}${PTARBALL:0:1}/$PTARBALL"
	URLS="$@ $alt_url $orig_url $orig_url_patch"
	[ "$LAN_MIRROR" ] && URLS="$alt_url $orig_url $orig_url_patch $@"
	if [ "$WGET_URL" = "$orig_url" ]; then
		[ "$TARBALL" = "$lzma_tarball" ] && LZMA_SRC=""
		get_source $@
	elif [ "$WGET_URL" = "$alt_url" ]; then
		LZMA_SRC=""
		get_source $@
	else
		for i in $URLS; do
			if [ "$1" = "$PATCH" ]; then
				[ ! -f "$SRC/$PTARBALL" ] || continue
			else
				[ ! -f "$SRC/$TARBALL" ] || continue
			fi
			case $i in 
				${url}*)
					[ "$i" = "$alt_url" ] && TARBALL="$(basename $alt_url)"
					[ "$i" = "$alt_url" ] && LZMA_SRC=""
					get_source $i 
					;;
				*)
					get_source $i ;;
			esac
		done
	fi
}

# Get source from multible urls
download() {
	if [ ! -s "$SRC/$TARBALL" ]; then
		download_base $WGET_URL
		[ -f "$SRC/$TARBALL" ] || broken
	fi
	
	if [ "$PATCH" ]; then
		if [ ! -s "$SRC/$PTARBALL" ]; then
			download_base $PATCH
			[ -f "$SRC/$PTARBALL" ] || broken
		fi
	fi
}

# Extract source package.
extract_source() {
	gettext "Extracting:"; echo " $TARBALL"
	case "$TARBALL" in
		*.tar.gz|*.tgz) tar xzf $SRC/$TARBALL 2>/dev/null ;;
		*.tar.bz2|*.tbz|*.tbz2) tar xjf $SRC/$TARBALL 2>/dev/null ;;
		*.tar.lzma) tar xaf $SRC/$TARBALL ;;
		*.tar) tar xf $SRC/$TARBALL ;;
		*.zip|*.xpi) unzip -o $SRC/$TARBALL ;;
		*.xz) unxz -c $SRC/$TARBALL | tar xf - ;;
		*.Z) uncompress -c $SRC/$TARBALL | tar xf - ;;
		*.rpm) rpm2cpio $SRC/$TARBALL | cpio -idm --quiet ;;
		*.deb) ar vx $SRC/$TARBALL
				[ ! -d $tmpsrc/$PACKAGE-$VERSION ] && mkdir -p $tmpsrc/$PACKAGE-$VERSION
				cd $tmpsrc/$PACKAGE-$VERSION
				tar -xvzf $tmpsrc/data.tar.gz 
				[ -f $tmpsrc/data.tar.gz ] && rm -f $tmpsrc/data.tar.gz 
				[ -f $tmpsrc/control.tar.gz ] && rm -f $tmpsrc/control.tar.gz
				[ -f $tmpsrc/debian-binary ] && rm -f $tmpsrc/debian-binary ;;
		*.run) /bin/sh $SRC/$TARBALL $RUN_OPTS ;;
		*.7z) 7zr x $SRC/$TARBALL ;;
		*) cp $SRC/$TARBALL $(pwd) ;;
	esac
	chown -R 0.0 $(pwd)
}

repack_source() {
	
	# Some archives are not well done and don't extract to one dir (ex lzma).
	files=$(ls | wc -l)
	[ "$files" == 1 ] && [ -d "$(ls)" ] && [ ! -d "$pkgsrc" ] && mv * $tmpsrc/$pkgsrc
	if [ ! -d "$tmpsrc/$pkgsrc" ]; then
		cd $basesrc
		if [ "$(ls -A tmp | wc -l)" -gt 1 ] || [ -f "$(echo tmp/*)" ]; then
			mv tmp tmp-1 && mkdir tmp
			mv tmp-1 tmp/$pkgsrc
		fi
	fi
	if [ -d "$tmpsrc/$pkgsrc" ]; then
		gettext "Repacking source is enabled:"; echo " LZMA_SRC"
		TARBALL=$lzma_tarball
		cd $tmpsrc
		if [ -x /usr/bin/optipng ]; then
			[ "$SHRINKPNG" ] && find -name "*.png" -type f | xargs -i optipng "{}"
		fi
		tar -c * | lzma e $SRC/$TARBALL -si $LZMA_SET_DIR
		if [ $REMOVE_ORIG_TARBALL ]; then
			if [ -f $SRC/$TARBALL ]; then
				[ -f $SRC/$orig_tarball ] && rm -f $SRC/$orig_tarball
			fi
		fi
	fi
}

# Display cooked package summary.
summary() {
	[ -d $WOK/$pkg/install ] && prod=$(du -sh $WOK/$pkg/install | awk '{print $1}' 2>/dev/null)
	[ -d $WOK/$pkg/source ] && srcdir=$(du -sh $WOK/$pkg/source | awk '{print $1}' 2>/dev/null)
	fs=$(du -sh $WOK/$pkg/taz/* | awk '{print $1}')
	size=$(du -sh $INCOMING/$pkg-${VERSION}*.tazpkg | awk '{print $1}')
	files=$(cat $WOK/$pkg/taz/$pkg-*/files.list | wc -l)
	[ "$TARBALL" ] && srcsize=$(du -sh $SRC/$TARBALL | awk '{print $1}')
	cookdate=$(date "+%Y-%m-%d %H:%M")
	sec=$time
	div=$(( ($time + 30) / 60))
	[ "$div" != 0 ] && min="~ ${div}m"
	gettext "Summary for:"; echo " $PACKAGE $VERSION"
	separator
	[ "$srcdir" ] && echo "Source dir  : $srcdir"
	[ "$TARBALL" ] && echo "Src file    : $TARBALL"
	[ "$srcsize" ] && echo "Src size    : $srcsize"
	[ "$prod" ] && echo "Produced    : $prod"
	cat << EOT
Packed      : $fs
Compressed  : $size
Files       : $files
Cook time   : ${sec}s $min
Cook date   : $cookdate
Host arch   : $ARCH
$(separator)
EOT
}

# Display debugging error info.
debug_info() {
	echo -e "\nDebug information"
	separator
	echo "Cook date: $(date '+%Y-%m-%d %H:%M')"
	for error in \
		ERROR "No package" "cp: can't" "can't open" "can't cd" \
		"error:" "fatal error:" "rm: can't remove" "cp: can't stat" \
		"undefined reference to" "Unable to connect to" \
		"link: cannot find the library" "CMake Error"
	do
		fgrep "$error" $LOGS/$pkg.log
	done
	separator && newline
}

# Copy all generic files (locale, pixmaps, .desktop). We use standard paths,
# so some packages need to copy these files with the receipt and genpkg_rules.
copy_generic_files()
{
	# $LOCALE is set in cook.conf
	if [ "$LOCALE" -a "$WANTED" = "" ]; then
		if [ -d "$install/usr/share/locale" ]; then
			mkdir -p $fs/usr/share/locale
			for i in $LOCALE
			do
				if [ -d "$install/usr/share/locale/$i" ]; then
					cp -a $install/usr/share/locale/$i $fs/usr/share/locale
				fi
			done
		fi
	fi

	# Generic pixmaps copy can be disabled with GENERIC_PIXMAPS="no"
	if [ "$GENERIC_PIXMAPS" != "no" ]; then
		if [ -d "$install/usr/share/pixmaps" ]; then
			mkdir -p $fs/usr/share/pixmaps
			if [ -f "$install/usr/share/pixmaps/$PACKAGE.png" ]; then
				cp -a $install/usr/share/pixmaps/$PACKAGE.png \
					$fs/usr/share/pixmaps
			elif [ -f "$install/usr/share/pixmaps/$PACKAGE.xpm" ]; then
				cp -a $install/usr/share/pixmaps/$PACKAGE.xpm \
					$fs/usr/share/pixmaps
			fi
		fi

		# Custom or homemade PNG pixmap can be in stuff.
		if [ -f "$stuff/$PACKAGE.png" ]; then
			mkdir -p $fs/usr/share/pixmaps
			cp -a $stuff/$PACKAGE.png $fs/usr/share/pixmaps
		fi
	fi

	# Desktop entry (.desktop).
	# Generic desktop entry copy can be disabled with GENERIC_MENUS="no"
	if [ "$GENERIC_MENUS" != "no" ]; then
		if [ -d "$install/usr/share/applications" ] && [ "$WANTED" == "" ]; then
			mkdir -p $fs/usr/share
			cp -a $install/usr/share/applications $fs/usr/share
		fi
	fi

	# Homemade desktop file(s) can be in stuff.
	if [ -d "$stuff/applications" ]; then
		mkdir -p $fs/usr/share
		cp -a $stuff/applications $fs/usr/share
	fi
	if [ -f "$stuff/$PACKAGE.desktop" ]; then
		mkdir -p $fs/usr/share/applications
		cp -a $stuff/$PACKAGE.desktop $fs/usr/share/applications
	fi
	
	# Add custom licenses
	if [ -d "$stuff/licenses" ]; then
		mkdir -p $fs/usr/share/licenses
		cp -a $stuff/licenses $fs/usr/share/licenses/$PACKAGE
	fi
}

# Find and strip : --strip-all (-s) or --strip-debug on static libs as well
# as removing uneeded files like in Python packages. Cross compiled binaries
# must be stripped with cross-tools aka $ARCH-slitaz-*-strip
strip_package()
{
	case "$ARCH" in
		arm|x86_64) export STRIP=${HOST_SYSTEM}-strip ;;
		*) export STRIP=strip ;;
	esac
	gettext "Executing strip on all files..."
	for dir in $fs/bin $fs/sbin $fs/usr/bin $fs/usr/sbin $fs/usr/games
	do
		if [ -d "$dir" ]; then
			find $dir -type f -exec $STRIP -s '{}' 2>/dev/null \;
		fi
	done
	find $fs -name "*.so*" -exec $STRIP -s '{}' 2>/dev/null \;
	find $fs -name "*.a" -exec $STRIP --strip-debug '{}' 2>/dev/null \;
	status

	# Remove Python .pyc and .pyo from packages.
	if echo "$PACKAGE $DEPENDS" | fgrep -q "python"; then
		gettext "Removing Python compiled files..."
		find $fs -type f -name "*.pyc" -delete 2>/dev/null
		find $fs -type f -name "*.pyo" -delete 2>/dev/null
		status
	fi

	# Remove Perl perllocal.pod and .packlist from packages.
	if echo "$DEPENDS" | fgrep -q "perl"; then
		gettext "Removing Perl compiled files..."
		find $fs -type f -name "perllocal.pod" -delete 2>/dev/null
		find $fs -type f -name ".packlist" -delete 2>/dev/null
		status
	fi
}

# Remove installed deps.
remove_deps() {
	# Now remove installed build deps.
	diff="$CACHE/installed.cook.diff"
	if [ -s "$CACHE/installed.cook.diff" ]; then
		deps=$(cat $diff | grep ^+[a-zA-Z0-9] | sed s/^+//)
		nb=$(cat $diff | grep ^+[a-zA-Z0-9] | wc -l)
		gettext "Build dependencies to remove:"; echo " $nb"
		gettext "Removing:"
		for dep in $deps
		do
			echo -n " $dep"
			tazpkg remove $dep --auto --root=/ >/dev/null
		done
		echo -e "\n"
		# Keep the last diff for debug and info.
		mv -f $CACHE/installed.cook.diff $CACHE/installed.diff
	fi
}

extract_path()
{
	# Some archives are not well done and don't extract to one dir (ex lzma).
	files=$(ls | wc -l)
	[ "$files" == 1 ] && [ -d "$(ls)" ] && mv * ../$PACKAGE-$VERSION
	[ "$files" == 1 ] && [ -f "$(ls)" ] && mkdir -p ../$PACKAGE-$VERSION && \
		mv * ../$PACKAGE-$VERSION/$TARBALL
	[ "$files" -gt 1 ] && mkdir -p ../$PACKAGE-$VERSION && \
		mv * ../$PACKAGE-$VERSION
	cd .. && rm -rf tmp
	if [ "$TOUCH_FILES" ]; then
		echo "Touching source files to update timestamp"
		echo "May take a bit"
		find $src -type f -exec touch "{}" \;
	fi
}

# The main cook function.
cookit() {
	echo "Cook: $PACKAGE $VERSION"
	separator
	set_paths

	# Handle cross-tools.
	case "$ARCH" in
		arm|x86_64)
			# CROSS_COMPILE is used by at least Busybox and the kernel to set
			# the cross-tools prefix but first check if sysroot is used.
			# the cross-tools prefix. Sysroot the the root of our target arch
			sysroot=$CROSS_TREE/sysroot
			tools=$CROSS_TREE/tools
			# Set root path when cross compiling. ARM tested but not x86_64
			# When cross compiling we must install build deps in $sysroot.
			arch="-${ARCH}"
			root=$sysroot
			echo "$ARCH sysroot: $sysroot"
			echo "Adding $tools/bin to PATH"
			export PATH=$PATH:$tools/bin
			export PKG_CONFIG_PATH=$sysroot/usr/lib/pkgconfig
			export CROSS_COMPILE=${HOST_SYSTEM}-
			echo "Using cross-tools: $CROSS_COMPILE"
			if [ "$ARCH" == "x86_64" ]; then
				export CC="${HOST_SYSTEM}-gcc -m64"
				export CXX="${HOST_SYSTEM}-g++ -m64"
			else
				export CC=${HOST_SYSTEM}-gcc
				export CXX=${HOST_SYSTEM}-g++
			fi
			export AR=${HOST_SYSTEM}-ar
			export AS=${HOST_SYSTEM}-as
			export RANLIB=${HOST_SYSTEM}-ranlib
			export LD=${HOST_SYSTEM}-ld
			export STRIP=${HOST_SYSTEM}-strip ;;
		*)
			root="/" ;;
	esac

	[ "$QA" ] && receipt_quality
	cd $pkgdir
	rm -rf install taz source

	# Disable -pipe if less than 512Mb free RAM.
	free=$(free | fgrep '/+ buffers' | tr -s ' ' | cut -f 4 -d ' ')
	if [ "$free" -lt 524288 ] && [ "$CFLAGS" != "${CFLAGS/-pipe}" ]; then
			gettext -e "Disabling -pipe compile flag: $free RAM\n"
			CFLAGS="${CFLAGS/-pipe}" && CFLAGS=$(echo "$CFLAGS" | tr -s ' ')
			CXXFLAGS="${CXXFLAGS/-pipe}" && \
				CXXFLAGS=$(echo "$CXXFLAGS" | tr -s ' ')
	fi
	unset free

	# Export flags and path to be used by make and receipt.
	DESTDIR=$pkgdir/install
	export DESTDIR MAKEFLAGS CFLAGS CXXFLAGS CONFIG_SITE LC_ALL=C LANG=C
	#export LDFLAGS

	if [ ! "$WANTED" ] && [ "$TARBALL" ]; then
		getsrc --extract
	fi

	# Check for build deps and handle implicit depends of *-dev packages
	# (ex: libusb-dev :: libusb).
	rm -f $CACHE/installed.local $CACHE/installed.web $CACHE/missing.dep
	touch $CACHE/installed.local $CACHE/installed.web
	look_for_cookopt !auto_dep && AUTO_DEP=""
	if [ "$AUTO_DEP" -a ! "$WANTED" ]; then
		BDEPS=$(scan $PACKAGE --look_for=bdep --with_dev | \
			grep -v $(for i in $(look_for_rwanted) $PACKAGE; do echo " -e ^$i$"; done))
	else
		BDEPS="$BUILD_DEPENDS"
	fi
	[ "$BDEPS" ] && gettext -e "Checking build dependencies...\n"
	[ "$root" != "/" ] && echo "Using packages DB: ${root}$DB"
	for dep in $BDEPS
	do
		for i in $dep
		do
			if [ ! -f "${root}$INSTALLED/$i/receipt" ]; then
				# Try local package first. In some cases implicit doesn't exist, ex:
				# libboost-dev exists but not libboost, so check if we got vers.
				unset vers
				[ -f $WOK/$i/receipt ] || continue
				vers=$(. $WOK/$i/receipt 2>/dev/null ; echo $VERSION)
				if [ -f "$INCOMING/$i-${vers}_${kbasevers}.tazpkg" ]; then
					echo $i-${vers}_${kbasevers}.tazpkg >> $CACHE/installed.local
				elif [ -f "$PKGS/$i-${vers}_${kbasevers}.tazpkg" ]; then
					echo $i-${vers}_${kbasevers}.tazpkg >> $CACHE/installed.local
				elif [ -f "$INCOMING/$i-$vers.tazpkg" ]; then
					echo $i-$vers.tazpkg >> $CACHE/installed.local
				elif [ -f "$PKGS/$i-$vers.tazpkg" ]; then
					echo $i-$vers.tazpkg >> $CACHE/installed.local
				else
					# Priority to package version in wok (maybe more up-to-date)
					# than the mirrored one.
					if [ "$vers" ]; then
						if fgrep -q $i-${vers}${arch} ${root}$DB/packages.list; then
							echo $i >> $CACHE/installed.web
						else
							# So package exists in wok but not available.
							gettext "Missing dep (wok/pkg):"; echo " $i $vers"
							echo $i >> $CACHE/missing.dep
						fi
					else
						# Package is not in wok but may be in online repo.
						if fgrep -q $i-${vers}${arch} ${root}$DB/packages.list; then
							echo $i >> $CACHE/installed.web
						else
							echo "ERROR: unknown dep $i" && exit 1
						fi
					fi
				fi
			fi
		done
	done

	# Get the list of installed packages
	ls -1 ${root}$INSTALLED > $CACHE/installed.list

	# Have we a missing build dep to cook ?
	if [ -s "$CACHE/missing.dep" ] && [ "$AUTO_COOK" ]; then
		gettext -e "Auto cook config is set   : AUTO_COOK\n"
		cp -f $LOGS/$PACKAGE.log $LOGS/$PACKAGE.log.$$
		for i in $(uniq $CACHE/missing.dep)
		do
			(gettext "Building dep (wok/pkg)    :"; echo " $i $vers") | \
				tee -a $LOGS/$PACKAGE.log.$$
			cook $i || (echo -e "ERROR: can't cook dep '$i'\n" && \
				fgrep "remove: " $LOGS/$i.log && \
				fgrep "Removing: " $LOGS/$i.log && newline) | \
				tee -a $LOGS/$PACKAGE.log.$$ && break
		done
		rm -f $CACHE/missing.dep
		mv  $LOGS/$PACKAGE.log.$$ $LOGS/$PACKAGE.log
	fi

	# QA: Exit on missing dep errors. We exit in both cases, if AUTO_COOK
	# is enabled and cook fails we have ERROR in log, if no auto cook we have
	# missing dep in cached file.
	if fgrep -q "ERROR:" $LOGS/$pkg.log || [ -s "$CACHE/missing.dep" ]; then
		[ -s "$CACHE/missing.dep" ] && nb=$(cat $CACHE/missing.dep | wc -l)
		echo "ERROR: missing dep $nb" && exit 1
	fi

	# Install local packages: package-version${arch}
	for i in $(uniq $CACHE/installed.local)
	do
		if [ -f "$INCOMING/$i" ]; then
			gettext "Installing dep (pkg/local):"; echo " $i"
			tazpkg install $INCOMING/$i --root=$root >/dev/null
		elif [ -f "$PKGS/$i" ]; then
			gettext "Installing dep (pkg/local):"; echo " $i"
			tazpkg install $PKGS/$i --root=$root >/dev/null
		fi
	done

	# Install web or cached packages (if mirror is set to $PKGS we only
	# use local packages).
	for i in $(uniq $CACHE/installed.web)
	do
		gettext "Installing dep (web/cache):"; echo " $i"
		tazpkg get-install $i --root=$root >/dev/null
	done

	# If a cook failed deps are removed.
	ls -1 ${root}$INSTALLED > $CACHE/installed.cook
	[ ! -s "$CACHE/installed.cook.diff" ] && \
		busybox diff $CACHE/installed.list $CACHE/installed.cook > $CACHE/installed.cook.diff
	deps=$(cat $CACHE/installed.cook.diff | grep ^+[a-zA-Z0-9] | wc -l)

	# Execute receipt rules.
	if [ $(grep ^compile_rules $receipt) ] && [ "$cook_code" = "" ]; then
		echo "Executing: compile_rules"
		echo "CFLAGS   : $CFLAGS"
		#echo "LDFLAGS  : $LDFLAGS"
		[ -d "$src" ] && cd $src
		compile_rules $@ || broken
		[ "$cook_code" ] && exit 1
		# Stay compatible with _pkg
		[ -d "$src/_pkg" ] && mv $src/_pkg $install
		# QA: compile_rules success so valid.
		mkdir -p $install
	else
		# QA: No compile_rules so no error, valid.
		mkdir -p $install
	fi
	separator && newline

	# Execute testsuite.
	if grep -q ^testsuite $receipt; then
		echo "Running testsuite"
		separator
		testsuite $@ || exit 1
		separator && newline
	fi
}

# Cook quality assurance.
cookit_quality() {
	if [ ! -d "$WOK/$pkg/install" ] && [ ! "$WANTED" ]; then
		echo -e "ERROR: cook failed" | tee -a $LOGS/$pkg.log
	fi
	# ERROR can be echoed any time in cookit()
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		debug_info | tee -a $LOGS/$pkg.log
		rm -f $command && exit 1
	fi
}

# Create the package. Wanted to use Tazpkg to create a tazpkg package at first,
# but it doesn't handle EXTRAVERSION.
packit() {
	set_paths

	# Handle cross compilation
	case "$ARCH" in
		arm|x86_64) arch="-$ARCH" ;;
	esac

	echo "Pack: $PACKAGE ${VERSION}${arch}"
	separator

	if grep -q ^genpkg_rules $receipt; then
		gettext -e "Executing: genpkg_rules\n"
		set -e && cd $pkgdir && mkdir -p $fs
		genpkg_rules || (broken && echo -e "\nERROR: genpkg_rules failed\n" >> \
			$LOGS/$pkg.log)
	else
		gettext "No packages rules: meta package"; echo
		mkdir -p $fs
	fi

	# First QA check to stop now if genpkg_rules failed.
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		broken && exit 1
	fi

	cd $taz
	for file in receipt description.txt
	do
		[ ! -f "../$file" ] && continue
		gettext "Copying"; echo -n " $file..."
		cp -f ../$file $pack && chown 0.0 $pack/$file && status
	done
	copy_generic_files

	# Create files.list with redirecting find output.
	gettext "Creating the list of files..." && cd $fs
	find . -type f -print > ../files.list
	find . -type l -print >> ../files.list
	cd .. && sed -i s/'^.'/''/ files.list
	status

	# Strip and stuff files.
	look_for_cookopt !strip && STRIP="n"
	[ "$STRIP" ] || strip_package

	# Md5sum of files.
	gettext "Creating $CHECKSUM of files..."
	while read file; do
		[ -L "fs$file" ] && continue
		[ -f "fs$file" ] || continue
		case "$file" in
			/lib/modules/*/modules.*|*.pyc) continue ;;
		esac
		$CHECKSUM "fs$file" | sed 's/  fs/  /'
	done < files.list > "$CHECKSUM"
	status
	UNPACKED_SIZE=$(du -chs fs receipt files.list $CHECKSUM \
		description.txt 2> /dev/null | awk \
		'{ sz=$1 } END { print sz }')
	
	if [ "$UPCOOKLIST" ]; then
		check_so_files
	fi
	
	# Generate md5 of cooking stuff to look for commit later.
	gen_cookmd5
	echo -e "\n# md5sum of cooking stuff :" >> receipt
	cat $WOK/$PACKAGE/md5 | sed 's/^/# /' >> receipt
	
	# Build cpio archives.
	gettext "Compressing the fs... "
	find fs | cpio -o -H newc --quiet | lzma e fs.cpio.lzma -si $LZMA_SET_DIR
	rm -rf fs
	status
	PACKED_SIZE=$(du -chs fs.cpio.lzma receipt files.list \
		$CHECKSUM description.txt 2> /dev/null | awk \
		'{ sz=$1 } END { print sz }')
	gettext "Updating receipt sizes..."
	sed -i s/^PACKED_SIZE.*$// receipt
	sed -i s/^UNPACKED_SIZE.*$// receipt
	sed -i "s/^PACKAGE=/PACKED_SIZE=\"$PACKED_SIZE\"\nUNPACKED_SIZE=\"$UNPACKED_SIZE\"\nPACKAGE=/" receipt
	status

	# Set extra version.
	if [ "$EXTRAVERSION" ]; then
		gettext "Updating receipt EXTRAVERSION: "; echo -n "$EXTRAVERSION"
		sed -i s/^EXTRAVERSION.*$// receipt
		sed -i "s/^VERSION=/EXTRAVERSION=\"$EXTRAVERSION\"\nVERSION=/" receipt
		status
	fi

	# Compress.
	gettext "Creating full cpio archive... "
	find . -print | cpio -o -H newc --quiet > \
		../$PACKAGE-${VERSION}${EXTRAVERSION}${arch}.tazpkg
	status
	gettext "Restoring original package tree... "
	unlzma -c fs.cpio.lzma | cpio -idm --quiet
	status
	rm fs.cpio.lzma && cd ..
	
	if [ "$UPCOOKLIST" ]; then
		check_recook_rdeps
	fi
	
	# QA and give info.
	tazpkg=$(ls *.tazpkg)
	packit_quality
	separator && gettext "Package:"; echo -e " $tazpkg\n"
}

# Verify package quality and consistency.
packit_quality() {
	#gettext "QA: Checking for broken link..."
	#link=$(find $fs/usr -type l -follow)
	#[ "$link" ] && echo -e "\nERROR: broken link in filesystem"
	#status

	# Exit if any error found in log file.
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		rm -f $command && exit 1
	fi

	gettext "QA: Checking for empty package..."
	files=$(cat $WOK/$pkg/taz/$pkg-*/files.list | wc -l)
	if [ "$files" == 0 ] && [ "$CATEGORY" != "meta" ]; then
		echo -e "\nERROR: empty package"
		rm -f $command && exit 1
	else
		# Ls sort by name so the first file is the one we want.
		old=$(ls $INCOMING/$pkg-[0-9]*.tazpkg 2>/dev/null | head -n 1)
		status
		if [ -f "$old" ]; then
			gettext "Removing old: $(basename $old)"
			rm -f $old && status
		fi
		mv -f $pkgdir/taz/$pkg-*.tazpkg $INCOMING
		sed -i /^${pkg}$/d $broken
	fi
}

# Install package on --install or update the chroot.
install_package()
{
	local pkg build
	case "$ARCH" in
		arm|x86_64)
			arch="-${ARCH}"
			root=$CROSS_TREE/sysroot ;;
		*)
			root="/" ;;
	esac
	# Install package if requested but skip install if target host doesn't
	# match build system or it will break the build chroot.
	build=$(echo $BUILD_SYSTEM | cut -d "-" -f 1)
	for pkg in $PACKAGE; do
		if [ -f "$inst" ] && [ "$build" == "$ARCH" ]; then
			if [ -f "$INCOMING/$pkg-${VERSION}${EXTRAVERSION}${arch}.tazpkg" ]; then
				echo "Updating $ARCH chroot environment..."
				echo "Updating chroot: $pkg (${VERSION}${EXTRAVERSION}${arch})" | log
				tazpkg install \
					$INCOMING/$pkg-${VERSION}${EXTRAVERSION}${arch}.tazpkg --root=$root --forced
			else
				gettext -e "Unable to install package, build has failed.\n\n"
				exit 1
			fi
		fi
	done
	
	# Install package if part of the chroot to keep env up-to-date.
	if [ -f "${root}$INSTALLED/$pkg/receipt" ]; then
		. /etc/slitaz/cook.conf
		. $WOK/$pkg/taz/$pkg-*/receipt
		echo "Updating $ARCH chroot environment..."
		echo "Updating chroot: $pkg (${VERSION}${EXTRAVERSION}${arch})" | log
		if [ -f "$PKGS/$PACKAGE-${VERSION}${EXTRAVERSION}${arch}.tazpkg" ]; then
			tazpkg install \
				$PKGS/$pkg-${VERSION}${EXTRAVERSION}${arch}.tazpkg \
				--forced --root=$root
		elif [ -f "$INCOMING/$PACKAGE-${VERSION}${EXTRAVERSION}${arch}.tazpkg" ]; then
			tazpkg install \
				$INCOMING/$pkg-${VERSION}${EXTRAVERSION}${arch}.tazpkg \
				--forced --root=$root
		fi
	fi
}

tac()
{
	sed '1!G;h;$!d' $1
}

unbuild()
{
	check_root
	get_options_list="full list"
	get_options
	[ -f $unbuild ] && rm -rf $unbuild
	LIST="$fullco"
	[ -f "$1" ] && LIST="$1"
	#[ "$full" ] && LIST=$(ls $WOK)
	if [ -f "$1" -a "$full" ]; then
		COMMAND=gen-cooklist
		gen_cook_list
		LIST="$tmp/cooklist"
	fi
	for pkg in $(cat $LIST | grep -v ^#); do
		unset VERSION PACKAGE
		[ -f $WOK/$pkg/receipt ] || continue
		. $WOK/$pkg/receipt
		if [ ! -f $INCOMING/$PACKAGE-${VERSION}*.tazpkg -a ! -f $PKGS/$PACKAGE-${VERSION}*.tazpkg ]; then
			echo "$PACKAGE" && echo "$PACKAGE" >> $unbuild
		fi
	done
	unset pkg
	[ "$list" ] && cp -a $unbuild $cooklist
}

# Launch the cook command into a chroot jail protected by aufs.
# The current filesystems are used read-only and updates are
# stored in a separate branch.
try_aufs_chroot() {

	base=/dev/shm/aufsmnt$$

	# Can we setup the chroot ? Is it already done ?
	grep -q ^AUFS_NOT_SUPPORTED $receipt && return
	[ -n "$AUFS_MOUNTS" -a ! -f /aufs-umount.sh ] || return
	lsmod | grep -q aufs || modprobe aufs 2> /dev/null || return
	mkdir ${base}root ${base}rw || return

	echo "Setup aufs chroot..."

	# Sanity check
	for i in / /proc /sys /dev/shm /dev/pts /home ; do
		case " $AUFS_MOUNTS " in
		*\ $i\ *) ;;
		*)	AUFS_MOUNTS="$AUFS_MOUNTS $i" ;;
		esac
	done
	for mnt in $(echo $AUFS_MOUNTS | sort | uniq); do
		mount --bind $mnt ${base}root$mnt
		if [ $mnt == / ] && ! mount -t aufs -o br=${base}rw:/ none ${base}root; then
			echo "Aufs mountage failure"
			umount ${base}root
			rmdir ${base}*
			return
		fi
		echo "umount ${base}root$mnt" >> ${base}rw/aufs-umount.sh
	done

	chroot ${base}root $(cd $(dirname $0); pwd)/$(basename $0) "$@"
	status=$?

	echo "Leaving aufs chroot..."
	tac ${base}rw/aufs-umount.sh | sh
	rm -rf ${base}rw
	umount ${base}root
	rmdir $base*

	# Install package if requested
	install_package
	exit $status
}

# Create a XML feed for freshly built package.
gen_rss() {
	pubdate=$(date "+%a, %d %b %Y %X")
	cat > $FEEDS/$pkg.xml << EOT
	<item>
		<title>$PACKAGE $VERSION${EXTRAVERSION}</title>
		<link>${COOKER_URL}?pkg=$PACKAGE</link>
		<guid>$PACKAGE-$VERSION${EXTRAVERSION}</guid>
		<pubDate>$pubdate</pubDate>
		<description>$SHORT_DESC</description>
	</item>
EOT
}



#
# Commands
#

case "$COMMAND" in
	usage|help|-u|-h)
		 usage ;;
	list-wok)
		gettext -e "\nList of packages in:"; echo " $WOK"
		separator
		cd $WOK && ls -1
		separator
		echo -n "Packages: " && ls | wc -l
		newline ;;
	activity)
		cat $activity ;;
	search)
		# Just a simple search function, we dont need more actually.
		query="$2"
		newline
		gettext "Search results for:"; echo " $query"
		separator
		cd $WOK && ls -1 | grep "$query"
		separator && newline ;;
	setup)
		# Setup a build environment
		check_root
		echo "Cook: setup environment" | log
		newline
		gettext "Setting up your environment"; newline
		separator && cd $SLITAZ
		init_db_files
		gettext "Checking for packages to install..."; echo
		# Use setup pkgs from cross.conf or cook.conf. When cross compiling
		# ARCH-setup or 'cross check-env' should be used before: cook setup
		case "$ARCH" in
			arm|x86_64)
				if [ ! -x "/usr/bin/cross" ]; then
					gettext "ERROR: cross is not installed"; echo
					exit 1
				fi
				gettext "Using config file: /etc/slitaz/cross.conf"; echo
				. /etc/slitaz/cross.conf ;;
		esac
		for pkg in $INSTALL_PKGS; do
			if [ "$forced" ]; then
				tazpkg -gi $pkg --forced
			else
				[ -f "$INSTALLED/$pkg/receipt" ] || tazpkg get-install $pkg
			fi
		done
		# chroot list
		ls -1 "$INSTALLED" > $CACHE/chroot-pkgs
		# Handle --options
		case "$2" in
			--wok)
				hg clone $WOK_URL $WOKHG || exit 1 ;;
			--stable)
				hg clone $WOK_URL-stable $WOKHG || exit 1 ;;
			--undigest)
				hg clone $WOK_URL-undigest $WOKHG || exit 1 ;;
			--tiny)
				hg clone $WOK_URL-tiny $WOKHG || exit 1 ;;
		esac

		rsync_wok
		
		# SliTaz group and permissions
		if ! grep -q ^slitaz /etc/group; then
			gettext -e "Adding group: slitaz\n"
			addgroup slitaz
		fi
		gettext -e "Setting permissions for slitaz group...\n"
		find $SLITAZ -maxdepth 2 -exec chown root.slitaz {} \;
		find $SLITAZ -maxdepth 2 -exec chmod g+w {} \;
		separator
		gettext -e "All done, ready to cook packages :-)\n\n" ;;
	*-setup)
		# Setup for cross compiling.
		arch=${1%-setup}
		check_root
		echo "Cook: setup $arch cross environment" | log
		newline
		boldify $(gettext "Setting up your $arch cross environment")
		separator
		init_db_files
		sed -i \
			-e s"/ARCH=.*/ARCH=\"$arch\"/" \
			-e s"/CROSS_TREE=.*/CROSS_TREE=\"\/cross\/$arch\"/" \
			-e s'/BUILD_SYSTEM=.*/BUILD_SYSTEM=i486-slitaz-linux/' \
			/etc/slitaz/cook.conf
		case "$arch" in
			arm)
				sed -i \
					-e s'/CFLAGS=.*/CFLAGS="-march=armv6 -O2"/' \
					-e s'/HOST_SYSTEM=.*/HOST_SYSTEM=$ARCH-slitaz-linux-gnueabi/' \
					-e s'/xorg-dev/""/' \
					/etc/slitaz/cook.conf ;;
			x86_64)
				sed -i \
					-e s'/CFLAGS=.*/CFLAGS=""/' \
					-e s'/HOST_SYSTEM=.*/HOST_SYSTEM=$ARCH-slitaz-linux/' \
					/etc/slitaz/cook.conf ;;
		esac
		. /etc/slitaz/cook.conf
		sysroot=$CROSS_TREE/sysroot
		tools=/cross/$arch/tools
		root=$sysroot
		CC=$tools/bin/${HOST_SYSTEM}-gcc
		echo "Target arch     : $ARCH"
		echo "Configure args  : $CONFIGURE_ARGS"
		echo "Arch sysroot    : $sysroot"
		echo "Tools prefix    : $tools/bin"
		# Tell the packages manager where to find packages.
		echo "Packages DB     : ${root}$DB"
		mkdir -p ${root}$INSTALLED
		cd ${root}$DB && rm -f *.bak
		for list in packages.list packages.desc packages.equiv packages.md5
		do
			rm -f $list && ln -s $SLITAZ/packages/$list $list
		done
		# We must have the cross compiled glibc-base installed or default
		# i486 package will be used as dep by tazpkg and then break the
		# cross environment
		if [ ! -f "${root}$INSTALLED/glibc-base/receipt" ]; then
			colorize 36 "WARNING: (e)glibc-base is not installed in sysroot"
		fi
		# Show GCC version or warn if not yet compiled.
		if [ -x $CC ]; then
			echo "Cross compiler  : ${HOST_SYSTEM}-gcc"
		else
			colorize 36 "C compiler is missing: ${HOST_SYSTEM}-gcc"
			echo "Run 'cross compile' to cook a toolchain"
		fi
		separator && newline ;;
	upwok)
		case "$2" in
			--local)
				gettext -e "Updating local chanages in wok-hg to wok...\n"
				rsync_wok || exit 1 
				exit 1 ;;
		esac
		
		gettext -e "Updating wok-hg...\n"
		if [ -d $WOKHG/.hg ]; then
			cd $WOKHG
			hg pull -u || exit 1
		fi
		cd $SLITAZ
		rsync_wok || exit 1 ;;
	test)
		# Test a cook environment.
		echo "Cook test: testing the cook environment" | log
		[ ! -d "$WOK" ] && exit 1
		[ ! -d "$WOK/cooktest" ] && cp -r $DATA/cooktest $WOK
		cook cooktest ;;
	new)
		# Create the package folder and an empty receipt.
		pkg="$2"
		[ "$pkg" ] || usage
		newline
		if [ -d "$WOKHG/$pkg" ]; then
			echo -n  "$pkg " && gettext "package already exists."
			echo -e "\n" && exit 1
		fi
		gettext "Creating"; echo -n " $WOKHG/$pkg"
		mkdir $WOKHG/$pkg && cd $WOKHG/$pkg && status
		gettext "Preparing the package receipt..."
		cp $DATA/receipt .
		sed -i s"/^PACKAGE=.*/PACKAGE=\"$pkg\"/" receipt
		status && newline

		# Interactive mode, asking and seding.
		case "$3" in
			--interactive|-x)
				gettext -e "Entering interactive mode...\n"
				separator
				echo "Package       : $pkg"
				# Version.
				echo -n "Version       : " ; read anser
				sed -i s/'VERSION=\"\"'/"VERSION=\"$anser\""/ receipt
				# Category.
				echo -n "Category      : " ; read anser
				sed -i s/'CATEGORY=\"\"'/"CATEGORY=\"$anser\""/ receipt
				# Short description.
				echo -n "Short desc    : " ; read anser
				sed -i s/'SHORT_DESC=\"\"'/"SHORT_DESC=\"$anser\""/ receipt
				# Maintainer.
				echo -n "Maintainer    : " ; read anser
				sed -i s/'MAINTAINER=\"\"'/"MAINTAINER=\"$anser\""/ receipt
				# License.
				echo -n "License       : " ; read anser
				sed -i s/'LICENSE=\"\"'/"LICENSE=\"$anser\""/ receipt
				# Web site.
				echo -n "Web site      : " ; read anser
				sed -i s#'WEB_SITE=\"\"'#"WEB_SITE=\"$anser\""# receipt
				newline
				# Wget URL.
				echo "Wget URL to download source tarball."
				echo "Example  : \$GNU_MIRROR/\$PACKAGE/\$TARBALL"
				echo -n "Wget url : " ; read anser
				sed -i s#'WGET_URL=\"$TARBALL\"'#"WGET_URL=\"$anser\""# receipt
				# Ask for a stuff dir.
				echo -n "Do you need a stuff directory ? (y/N) : " ; read anser
				if [ "$anser" = "y" ]; then
					echo -n "Creating the stuff directory..."
					mkdir -p $WOKHG/$pkg/stuff && status
				fi
				# Ask for a description file.
				echo -n "Are you going to write a description ? (y/N) : " ; read anser
				if [ "$anser" = "y" ]; then
					echo -n "Creating the description.txt file..."
					newline > $WOKHG/$pkg/description.txt && status
				fi
				separator
				gettext -e "Receipt is ready to use.\n"
				newline ;;
		esac ;;
	list)
		# Cook a list of packages (better use the Cooker since it will order
		# packages before executing cook).
		check_root
		[ -z "$2" ] && gettext -e "\nNo list in argument.\n\n" && exit 1
		[ ! -f "$2" ] && gettext -e "\nNo list found:" && \
			echo -e " $2\n" && exit 1
		echo "Cook list starting: $2" | log
		for pkg in $(cat $2)
		do
			cook $pkg || broken
		done ;;
	clean-wok)
		check_root
		gettext -e "\nCleaning all packages files..."
		rm -rf $WOK/*/taz $WOK/*/install $WOK/*/source
		status && newline ;;
	clean-src)
		check_root
		gettext -e "\nCleaning all packages sources..."
		rm -rf $WOK/*/source
		status && newline ;;
	gen-cooklist)
		check_root
		[ -f "$2" ] && LIST="$2"
		get_options_list="pkg wok missing"
		get_options
		if ! [ "$pkg" ]; then
			if [ ! "$LIST" ] || [ "$LIST" = "toolchain" ]; then
				pkg="$TOOLCHAIN $TOOLCHAIN_EXTRA"
			else
				check_for_list
			fi
		fi
		gen_cook_list
		if [ "$missing" ]; then
			cooklist=${LIST:-$cooklist}
			for pkgname in $(cat $cooklist)
			do
				unset EXTRAVERSION
				[ -f $wok/$pkgname/receipt ] || continue
				. $wok/$pkgname/receipt
				if [ -f $INCOMING/$PACKAGE-${VERSION}*.tazpkg -o -f $PKGS/$PACKAGE-${VERSION}*.tazpkg ]; then
					if grep "^$pkgname" $cooklist; then
						sed -i "s|^$pkgname$||g" $cooklist
						sed -i /^$/d $cooklist
					fi
				fi
			done
		fi

		#rm -f $command 
		;;
	gen-wok-db)
		check_root
		#echo "cook:gen-wok-db" > $command
		[ -d "$WOKHG" ] && WOK="$WOKHG"
		[ "$2" ] && WOK="$2"
		gen_wok_db ;;
	check-incoming)
		check_root
		get_options_list="forced"
		get_options
		echo "cook:check-incoming" > $command
		check_for_incoming
		rm -f $command ;;
	gen-src)
		check_root
		[ "$2" ] && src_repository="$2"
		[ -d "$src_repository" ] || src_repository="$SRC"
		gettext -e "Rebulding sources.list file: $src_repository"
		gen_sources_list $src_repository
		status ;;
	maintainers)
		check_root
		newline
		echo "List of maintainers for: $WOK"
		separator
		tmp="/tmp/slitaz-maintainers"
		touch $tmp
		for pkg in $WOK/*
		do
			[ -f $pkg/receipt ] || continue
			. $pkg/receipt
			if ! fgrep -q "$MAINTAINER" $tmp; then
				echo "$MAINTAINER" >> $tmp
				echo "$MAINTAINER"
			fi
		done
		separator
		echo "Maintainers: `cat $tmp | wc -l`"
		newline
		# Remove tmp files
		[ -f $tmp ] && rm -f $tmp
	;;
	tags)
		check_root
		echo -e "\n\033[1mTags list :\033[0m"
		separator
		tmp="/tmp/tags"
		touch $tmp
		for pkg in $WOK/*; do
			unset TAGS
			[ -f $pkg/receipt ] || continue
			source $pkg/receipt
			for t in $TAGS; do
				grep -q ^$t$ $tmp && continue
				echo $t | tee -a $tmp
			done
		done
		separator
		echo "$(wc -l $tmp | cut -f1 -d ' ') tags listed."
		[ -f $tmp ] && rm -rf $tmp
	;;
	maintained-by)
		# Search for packages maintained by a contributor.
		check_root
		if [ ! -n "$2" ]; then
			echo "Specify a name or email of a maintainer." >&2
			exit 1
		fi
		echo "Maintainer packages"
		separator
		for pkg in $WOK/*
		do
			[ -f $pkg/receipt ] || continue
			. $pkg/receipt
			if echo "$MAINTAINER" | fgrep -q "$2"; then
				echo "$PACKAGE"
				packages=$(($packages+1))
			fi
		done
		separator
		echo "Packages maintained by $2: $packages"
		newline
	;;
	check-src)
		# Verify if upstream package is still available.
		#
		check_root
		PACKAGE="$2"
		receipt="$WOK/$PACKAGE/receipt"
		if [ ! -f $receipt ]; then
			gettext -e "\nUnable to find package in the wok:"
				echo -e " $PACKAGE\n" && exit 1
		fi
		unset_receipt
		source $receipt
		check_src()
		{
			for url in $@; do
				busybox wget -s $url  2>/dev/null && break
			done
		}
		if [ "$WGET_URL" ];then
			echo -n "$PACKAGE : "
			check_src $WGET_URL
			status
		else
			echo "No tarball to check for $PACKAGE"
		fi
	;;
	unbuild)
		unbuild "$2" "$3" ;;
	pkgdb)
		# Create suitable packages list for TazPKG and only for built packages
		# as well as flavors files for TazLiTo. We dont need logs since we do it
		# manually to ensure everything is fine before syncing the mirror.
		pkgdb "$2"
		exit 0 ;;
	clean-chroot)
		clean_chroot ;;
	*)
		# Just cook and generate a package.
		check_root
		time=$(date +%s)
		pkg="$1"
		[ -z "$pkg" ] && usage
		receipt="$WOK/$pkg/receipt"
		check_pkg_in_wok && newline

		unset inst
		unset_receipt
		. $receipt

		# Handle cross compilation.
		#
		# CROSS_NOTE: Actually we are running an ARM cooker but running
		# the cooker and build each commit in wok is not possible since
		# we dont cook the full wok for this arch. For ARM we need a set
		# of packages to handle a touch screen desktop, servers but not
		# erland.
		#
		# The temporary solution is to build only reviewed and tested
		# packages with HOST_ARCH set in receipt.
		case "$ARCH" in
			arm)
				if [ ! "$HOST_ARCH" ]; then
					echo "cook: HOST_ARCH is not set in $pkg receipt"
					echo "cook: This package is not included in: $ARCH"
					[ "$CROSS_BUGS" ] && echo "bugs: $CROSS_BUGS"
					echo "Cook skip: $pkg is not included in: $ARCH" | log
					newline && exit 1
				fi ;;
		esac

		# Some packages are not included in some arch or fail to cross compile.
		: ${HOST_ARCH=i486}
		if ! $(echo "$HOST_ARCH" | fgrep -q $ARCH); then
			echo "cook: HOST_ARCH=$HOST_ARCH"
			echo "cook: $pkg doesn't cook or is not included in: $ARCH"
			[ "$CROSS_BUGS" ] && echo "bugs: $CROSS_BUGS"
			echo "Cook skip: $pkg doesn't cook or is not included in: $ARCH" | log
			newline && exit 1
		fi

		# Skip blocked, 3 lines also for the Cooker.
		if grep -q "^$pkg$" $blocked && [ "$2" != "--unblock" ]; then
			gettext -e "Blocked package:"; echo -e " $pkg\n" && exit 0
		fi

		if [ "$AUFS_MODE" ]; then
			try_aufs_chroot "$@"
		fi

		# Log and source receipt.
		echo "Cook started for: <a href='cooker.cgi?pkg=$pkg'>$pkg</a>" | log
		echo "cook:$pkg" > $command

		# Display and log info if cook process stopped.
		trap 'gettext -e "\n\nCook stopped: control-C\n\n" | \
			tee -a $LOGS/$pkg.log' INT

		set_paths

		# Handle --options
		case "$2" in
			--clean|-c)
				gettext -e "Cleaning:"; echo -n " $pkg"
				cd $WOK/$pkg && rm -rf install taz source
				status && newline && exit 0 ;;
			--install|-i)
				inst='yes' ;;
			--noupdate|-nu)
				UPCHROOT="" ;;
			--nocleanchroot|-ncc)
				CLEAN_CHROOT="" ;;
			--getsrc|-gs)
				getsrc "$3"
				exit 0 ;;
			--block|-b)
				gettext "Blocking:"; echo -n " $pkg"
				[ $(grep "^$pkg$" $blocked) ] || echo "$pkg" >> $blocked
				status && newline && exit 0 ;;
			--unblock|-ub)
				gettext "Unblocking:"; echo -n " $pkg"
				sed -i "/^${pkg}$/"d $blocked
				status && newline && exit 0 ;;
			--pack)
				if [ -d $WOK/$pkg/taz ]; then
					rm -rf $WOK/$pkg/taz
					[ -f $LOGS/$pkg-pack.log ] && rm -rf $LOGS/$pkg-pack.log
					packit 2>&1 | tee -a $LOGS/$pkg-pack.log
					clean_log
				else
					gettext "Need to build $pkg." && exit 0
				fi
				exit 0 ;;
		esac

		# Check if wanted is built now so we have separate log files.
		if [ "$WANTED" ]; then
			if grep -q "^$WANTED$" $blocked; then
				echo "WANTED package $PACKAGE is blocked: $WANTED" | tee $LOGS/$pkg.log
				newline && rm -f $command && exit 1
			fi
			if grep -q "^$WANTED$" $broken; then
				echo "WANTED package $PACKAGE is broken: $WANTED" | tee $LOGS/$pkg.log
				newline && rm -f $command && exit 1
			fi
			if [ ! "$COOK_WANTED" ]; then
				if [ ! -d "$WOK/$WANTED/install" ]; then
					cook "$WANTED" || exit 1
				fi
			fi
		fi
		
		if [ "$UPCOOKLIST" ]; then
			db_md5=$(md5sum $dep_db $wan_db)
			echo "update_wok_db"
			update_wan_db
			echo "check_for_commit"
			check_for_commit
			sort -o $dep_db $dep_db
			sort -o $wan_db $wan_db
			if [ "$db_md5" != "$(md5sum $dep_db $wan_db)" ]; then
				grep -q "^#" $fullco || sed 1i"#PlanSort" -i $fullco
			fi
		fi
		
		# Cook and pack or exit on error and log everything.
		cookit $@ 2>&1 | tee $LOGS/$pkg.log
		remove_deps | tee -a $LOGS/$pkg.log
		if [ "$CLEAN_CHROOT" ]; then
			clean_chroot | tee -a $LOGS/$pkg.log
		fi
		cookit_quality
		packit 2>&1 | tee -a $LOGS/$pkg.log
		clean_log

		# Exit if any error in packing.
		if grep -q ^ERROR $LOGS/$pkg.log; then
			debug_info | tee -a $LOGS/$pkg.log
			broken
			rm -f $command && exit 1
		fi

		# This is needed cause unset and source receipt again
		if [ -f "$SRC/$lzma_tarball" ]; then
			TARBALL="$lzma_tarball"
		fi

		# Create an XML feed
		gen_rss

		# Time and summary
		time=$(($(date +%s) - $time))
		summary | tee -a $LOGS/$pkg.log
		newline

		if [ "$AUTO_PURGE_SRC" ]; then
			if [ -f "$SRC/$TARBALL" ]; then
				previous_tarball=$(grep ^$PACKAGE:incoming $SRC/sources.list | cut -f2)
				if [ -f "$SRC/$previous_tarball" ]; then
					sed "/^$PACKAGE:incoming/ s/.*/$PACKAGE:incoming\t$TARBALL/" \
						-i $SRC/sources.list
					grep -q $'\t'$previous_tarball$ $SRC/sources.list || \
						rm -f $SRC/$previous_tarball
				else
					echo -e "$PACKAGE:incoming\t$TARBALL" >> $SRC/sources.list
				fi
			fi
		fi
		
		# remove source folder if its not used in
		# genpkg_rules in all wanted packages
		remove_src

		install_package
		
		# Regen the cooklist if it was planned and command is not cook.
		[ "$regen_cooklist" -a "$UPCOOKLIST" ] && unset regen_cooklist && sort_cooklist
		
		if [ $(grep -l "^$pkg$" $broken) ]; then
			sed -i "^$pkg$" $broken
		fi
		# Finally we DONT WANT to build the *-dev or packages with WANTED="$pkg"
		# You want automation: use the Cooker Build Bot.
		rm -f $command ;;
esac

exit 0
