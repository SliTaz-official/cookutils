#!/bin/sh
#
# Cook - A tool to cook and generate SliTaz packages. Read the README
# before adding or modifing any code in cook!
#
# Copyright (C) SliTaz GNU/Linux - GNU gpl v3
# Author: Christophe Lincoln <pankso@slitaz.org>
#

[ -f "/etc/slitaz/cook.conf" ] && . /etc/slitaz/cook.conf
[ -f "cook.conf" ] && . ./cook.conf

# Share DB and status with the Cooker.
activity="$CACHE/activity"
command="$CACHE/command"
broken="$CACHE/broken"
blocked="$CACHE/blocked"

#
# Functions
#

usage() {
	cat << EOT

$(echo -e "\033[1m$(gettext "Usage:")\033[0m") cook [package|command|list] [--option]

$(echo -e "\033[1m$(gettext "Commands:")\033[0m")
  usage|help      $(gettext "Display this short usage.")
  setup           $(gettext "Setup your build environment.")
  test            $(gettext "Test environment and cook a package.")
  list-wok        $(gettext "List packages in the wok.")
  search          $(gettext "Simple packages search function.")
  new             $(gettext "Create a new package with a receipt".)
  list            $(gettext "Cook a list of packages.") 
  clean-wok       $(gettext "Clean-up all packages files.")
  clean-src       $(gettext "Clean-up all packages sources.")
  pkglist         $(gettext "Create all packages.* lists.")

$(echo -e "\033[1m$(gettext "Options:")\033[0m")
  --clean|-c      Cook : $(gettext "clean the package in the wok.")
  --install|-i    Cook : $(gettext "cook and install the package.")
  --getsrc|-gs    Cook : $(gettext "get the package source tarball.")
  --block|-b      Cook : $(gettext "Block a package so cook will skip it.")
  --unblock|-ub   Cook : $(gettext "Unblock a blocked package.")
  --wok|-w        Setup: $(gettext "create also a wok from Hg repo.")

EOT
	exit 0
}

# Be sure we're root.
check_root() {
	[ $(id -u) != 0 ] && gettext -e "\nYou must be root to cook.\n\n" && exit 0
}

separator() {
	echo "================================================================================"
}

status() {
	echo -en "\\033[70G[ "
	if [ $? = 0 ]; then
		echo -en "\\033[1;32mOK"
	else
		echo -en "\\033[1;31mFailed"
	fi
	echo -e "\\033[0;39m ]"
}

# Log activities, we want first letter capitalized.
log() {
	grep ^[A-Z] | \
		sed s"#^[A-Z]\([^']*\)#$(date '+%Y-%m-%d %H:%M') : \0#" >> $activity
}

# We don't want these escapes in web interface.
clean_log() {
	sed -i -e s'|\[70G\[ \[1;32m| |' \
		-e s'|\[0;39m \]||' $LOGS/$pkg.log
}

# Log broken packages.
broken() {
	if ! grep -q "^$pkg$" $broken; then
		echo "$pkg" >> $broken
	fi
}

# Be sure package exists in wok.
check_pkg_in_wok() {
	if [ ! -d "$WOK/$pkg" ]; then
		gettext -e "\nUnable to find package in the wok:"
		echo -e " $pkg\n" && exit 1
	fi
}

if_empty_value() {
	if [ -z "$value" ]; then
		gettext "QA: empty variable:"; echo -e " ${var}=\"\"\n"
		exit 1
	fi
}

# Initialize files used in $CACHE
init_db_files() {
	gettext "Creating directories structure in:"; echo " $SLITAZ"
	mkdir -p $WOK $PKGS $SRC $CACHE $LOGS
	gettext "Creating DB files in:"; echo " $CACHE"
	for f in $activity $command $broken $blocked
	do
		touch $f
	done
}

# QA: check a receipt consistency before building.
receipt_quality() {
	gettext -e "QA: checking package receipt...\n"
	unset online
	if ifconfig | grep -q -A 1 "^[a-z]*[0-9]" | fgrep 'addr:'; then
		online="online"
	fi
	for var in PACKAGE VERSION CATEGORY SHORT_DESC MAINTAINER WEB_SITE
	do
		unset value
		value=$(grep ^$var= $receipt | cut -d \" -f 2)
		case "$var" in
			PACKAGE|VERSION|SHORT_DESC)
				if_empty_value ;;
			CATEGORY)
				[ -z "$value" ] && value="empty"
				valid="base-system x-window utilities network graphics \
					multimedia office development system-tools security games \
					misc meta non-free"
				if ! echo "$valid" | grep -q -w "$value"; then
					gettext "QA: unknown category:"; echo -e " $value\n"
					exit 1
				fi ;;
			WEB_SITE)
				# We don't check WGET_URL since if dl is needed it will fail.
				# Break also if we're not online. Here error is not fatal.
				if_empty_value
				[ -z "$online" ] || break
				if ! busybox wget -s $value 2>/dev/null; then
					gettext "QA: Unable to reach:"; echo -e " $value"
				fi ;;
		esac
	done
}

# Executed before sourcing a receipt.
unset_receipt() {
	unset DEPENDS BUILD_DEPENDS WANTED EXTRAVERSION WGET_URL PROVIDE TARBALL
}

# Paths used in receipt and by cook itself.
set_paths() {
	pkgdir=$WOK/$PACKAGE
	src=$pkgdir/source/$PACKAGE-$VERSION
	taz=$pkgdir/taz
	pack=$taz/$PACKAGE-${VERSION}${EXTRAVERSION}
	fs=$pack/fs
	stuff=$pkgdir/stuff
	install=$pkgdir/install
	if [ "$WANTED" ]; then
		src=$WOK/$WANTED/source/$WANTED-$VERSION
		install=$WOK/$WANTED/install
	fi
	# Old way compatibility.
	_pkg=$install
}

# Get package source.
get_source() {
	case "$WGET_URL" in
		http://*|ftp://*)
			# Busybox Wget is better!
			busybox wget -c -P $SRC $WGET_URL || \
				(echo -e "ERROR: wget $WGET_URL" && exit 1) ;;
		hg*|mercurial*)
			# We are in cache so clone here and create a tarball
			if $(echo "$WGET_URL" | fgrep -q "hg|"); then
				url=${WGET_URL#hg|}
			else
				url=${WGET_URL#mercurial|}
			fi
			pkgsrc=${SOURCE:-$PACKAGE}-$VERSION
			tarball=$pkgsrc.tar.bz2
			gettext -e "Getting source from Hg...\n"
			echo "URL: $url"
			gettext "Cloning to: "; echo "$pwd/$pkgsrc"
			hg clone $url $pkgsrc || (echo "ERROR: hg clone $url" && exit 1)
			gettext "Creating tarball: "; echo "$tarball"
			tar cjf $tarball $pkgsrc || exit 1
			mv $tarball $SRC && rm -rf $pkgsrc ;;
		git*)
			url=${WGET_URL#git|}
			pkgsrc=${SOURCE:-$PACKAGE}-$VERSION
			tarball=$pkgsrc.tar.bz2
			gettext -e "Getting source from Git...\n"
			echo "URL: $url"
			git clone $url $pkgsrc || (echo "ERROR: git clone $url" && exit 1)
			if [ "$BRANCH" ]; then
				cd $pkgsrc && git checkout $BRANCH && cd ..	
			fi
			gettext "Creating tarball: "; echo "$tarball"
			tar cjf $tarball $pkgsrc || exit 1
			mv $tarball $SRC && rm -rf $pkgsrc ;;
		svn*|subversion*)
			echo "TODO: svn implementation in cook" && exit 1 ;;
		*)
			gettext -e "\nERROR: Unable to handle:"; echo -e " $WGET_URL \n" | \
				tee -a $LOGS/$PACKAGE.log
			exit 1 ;;
	esac
}

# Extract source package.
extract_source() {
	gettext "Extracting:"; echo " $TARBALL"
	case "$TARBALL" in
		*.tar.gz|*.tgz) tar xzf $SRC/$TARBALL ;;
		*.tar.bz2|*.tbz) tar xjf $SRC/$TARBALL ;;
		*.tar.lzma) tar xaf $SRC/$TARBALL ;;
		*.tar) tar xf $SRC/$TARBALL ;;
		*.zip|*.xpi) unzip -o $SRC/$TARBALL ;;
		*.xz) unxz -c $SRC/$TARBALL | tar xf - ;;
		*.Z) uncompress -c $SRC/$TARBALL | tar xf - ;;
		*.rpm) rpm2cpio $SRC/$TARBALL | cpio -idm --quiet ;;
	esac
}

# Display cooked package summary.
summary() {
	cd $WOK/$pkg
	[ -d install ] && prod=$(du -sh install | awk '{print $1}' 2>/dev/null)
	fs=$(du -sh taz/* | awk '{print $1}')
	size=$(du -sh $PKGS/$pkg-${VERSION}*.tazpkg | awk '{print $1}')
	files=$(cat taz/$pkg-*/files.list | wc -l)
	cookdate=$(date "+%Y-%m-%d %H:%M")
	sec=$time
	min="[ $(($time / 60)m ]"
	[ "$min" == 0 ] && min=""
	gettext "Summary for:"; echo " $PACKAGE $VERSION"
	separator
	[ "$prod" ] && echo "Produced   : $prod"
	cat << EOT
Packed     : $fs
Compressed : $size
Files      : $files
Cook time  : ${sec}s $min
Cook date  : $cookdate
$(separator)
EOT
}

# Display debugging error info.
debug_info() {
	echo -e "\nDebug information"
	separator
	echo "Cook date: $(date '+%Y-%m-%d %H:%M')"
	for error in \
		ERROR "No package" "cp: can't" "can't open" "can't cd" \
		"error:" "fatal error:"
	do
		fgrep "$error" $LOGS/$pkg.log
	done
	separator && echo ""
}

# Copy all generic files (locale, pixmaps, .desktop). We use standard paths,
# so some packages need to copy these files with the receipt and genpkg_rules.
copy_generic_files()
{
	# $LOCALE is set in cook.conf
	if [ "$LOCALE"  ]; then
		if [ -d "$_pkg/usr/share/locale" ]; then
			mkdir -p $fs/usr/share/locale
			for i in $LOCALE
			do
				if [ -d "$_pkg/usr/share/locale/$i" ]; then
					cp -a $_pkg/usr/share/locale/$i $fs/usr/share/locale
				fi
			done
		fi
	fi

	# Generic pixmaps copy can be disabled with GENERIC_PIXMAPS="no"
	if [ "$GENERIC_PIXMAPS" != "no" ]; then
		if [ -d "$_pkg/usr/share/pixmaps" ]; then
			mkdir -p $fs/usr/share/pixmaps
			cp -a $_pkg/usr/share/pixmaps/$PACKAGE.png \
				$fs/usr/share/pixmaps 2>/dev/null
			cp -a $_pkg/usr/share/pixmaps/$PACKAGE.xpm \
				$fs/usr/share/pixmaps 2>/dev/null
		fi

		# Custom or homemade PNG pixmap can be in stuff.
		if [ -f "$stuff/$PACKAGE.png" ]; then
			mkdir -p $fs/usr/share/pixmaps
			cp -a $stuff/$PACKAGE.png $fs/usr/share/pixmaps
		fi
	fi

	# Desktop entry (.desktop).
	if [ -d "$_pkg/usr/share/applications" ]; then
		cp -a $_pkg/usr/share/applications $fs/usr/share
	fi

	# Homemade desktop file(s) can be in stuff.
	if [ -d "$stuff/applications" ]; then
		mkdir -p $fs/usr/share
		cp -a $stuff/applications $fs/usr/share
	fi
	if [ -f "$stuff/$PACKAGE.desktop" ]; then
		mkdir -p $fs/usr/share/applications
		cp -a $stuff/$PACKAGE.desktop $fs/usr/share/applications
	fi
}

# Find and strip : --strip-all (-s) or --strip-debug on static libs as well
# as removing uneeded files like in Python packages.
strip_package()
{
	gettext "Executing strip on all files..."
	for dir in $fs/bin $fs/sbin $fs/usr/bin $fs/usr/sbin $fs/usr/games
	do
		if [ -d "$dir" ]; then
			find $dir -type f -exec strip -s '{}' 2>/dev/null \;
		fi
	done
	find $fs -name "*.so*" -exec strip -s '{}' 2>/dev/null \;
	find $fs -name "*.a" -exec strip --strip-debug '{}' 2>/dev/null \;
	status

	# Remove .pyc, .pyo, perllocal.pod and .packlist files from packages.
	if echo "$DEPENDS" | fgrep "python"; then
		gettext "Removing Python compiled files..."
		find $fs -type f -name "*.pyc" -delete 2>/dev/null
		find $fs -type f -name "*.pyo" -delete 2>/dev/null
		find $fs -type f -name "perllocal.pod" -delete 2>/dev/null
		find $fs -type f -name ".packlist" -delete 2>/dev/null
		status
	fi
}

# Remove installed deps.
remove_deps() {
	# Now remove installed build deps.
	diff="$CACHE/installed.diff"
	deps=$(cat $diff | grep ^+[a-zA-Z0-9] | sed s/^+//)
	nb=$(cat $diff | grep ^+[a-zA-Z0-9] | wc -l)
	if [ -s "$CACHE/installed.diff" ]; then
		gettext "Build dependencies to remove:"; echo " $nb"
		gettext "Removing:"
		for dep in $deps
		do
			echo -n " $dep"
			yes | tazpkg remove $dep >/dev/null
		done
		echo -e "\n"
		mv -f $CACHE/installed.diff $CACHE/installed.last.diff
	fi
}

# The main cook function.
cookit() {
	echo "Cook: $PACKAGE $VERSION"
	separator
	set_paths
	[ "$QA" ] && receipt_quality
	cd $pkgdir
	rm -rf install taz source

	# Disable -pipe if less than 512Mb free RAM.
	free=$(free | fgrep '/+ buffers' | tr -s ' ' | cut -f 4 -d ' ')
	if [ "$free" -lt 524288 ] && [ "$CFLAGS" != "${CFLAGS/-pipe}" ]; then
			gettext -e "Disabling -pipe compile flag: $free RAM\n"
			CFLAGS="${CFLAGS/-pipe}" && CFLAGS=$(echo "$CFLAGS" | tr -s ' ')
			CXXFLAGS="${CXXFLAGS/-pipe}" && \
				CXXFLAGS=$(echo "$CXXFLAGS" | tr -s ' ')
	fi
	unset free

	# Export flags and path to be used by make
	DESTDIR=$pkgdir/install
	export DESTDIR MAKEFLAGS CFLAGS CXXFLAGS BUILD_HOST CONFIG_SITE
	local LC_ALL=POSIX LANG=POSIX

	# Check for build deps.
	cd $INSTALLED && ls -1 > $CACHE/installed.list
	[ "$DEPENDS" ] && gettext -e "Checking build dependencies...\n"
	for dep in $BUILD_DEPENDS
	do
		if [ ! -f "$INSTALLED/$dep/receipt" ]; then
			# Try local package first
			if [ -f "$PKGS/$dep-*.tazpkg" ]; then
				gettext "Installing dep (local):"; echo " $dep"
				cd $PKGS && tazpkg install $dep-*.tazpkg >/dev/null
			else
				gettext "Installing dep (web/cache):"; echo " $dep"
				tazpkg get-install $dep >/dev/null
			fi
		fi
	done
	ls -1 > $CACHE/installed.cook && cd $CACHE
	
	# If a cook failed deps are not removed since we exit 1.
	[ ! -s "installed.diff" ] && \
		diff installed.list installed.cook > installed.diff
	deps=$(cat installed.diff | grep ^+[a-zA-Z0-9] | wc -l)

	# Get source tarball and make sure we have source dir named:
	# $PACKAGE-$VERSION to be standard in receipts. Here we use tar.lzma
	# tarball if it exists.
	if [ "$WGET_URL" ] && [ ! -f "$SRC/$TARBALL" ]; then
		if [ -f "$SRC/${SOURCE:-$PACKAGE}-$VERSION.tar.lzma" ]; then
			TARBALL=${SOURCE:-$PACKAGE}-$VERSION.tar.lzma
		else
			get_source || exit 1
		fi
	fi
	if [ ! "$WANTED" ] && [ "$TARBALL" ] && [ ! -d "$src" ]; then
		mkdir -p $pkgdir/source/tmp && cd $pkgdir/source/tmp
		extract_source || exit 1
		# Some archives are not well done and don't extract to one dir (ex lzma).
		files=$(ls | wc -l)
		[ "$files" == 1 ] && mv * ../$PACKAGE-$VERSION
		[ "$files" -gt 1 ]  && mkdir -p ../$PACKAGE-$VERSION && \
			mv * ../$PACKAGE-$VERSION
		cd .. && rm -rf tmp
	fi

	# Execute receipt rules.
	if grep -q ^compile_rules $receipt; then
		gettext -e "Executing: compile_rules\n"
		[ -d "$src" ] && cd $src
		compile_rules $@ || exit 1
		# Stay compatible with _pkg
		[ -d "$src/_pkg" ] && mv $src/_pkg $install
		# QA: compile_rules success so valid.
		mkdir -p $install
	else
		# QA: No compile_rules so no error, valid.
		mkdir -p $install
	fi
	separator && echo ""
}

# Cook quality assurance.
cookit_quality() {
	if [ ! -d "$WOK/$pkg/install" ] && [ ! "$WANTED" ]; then
		echo -e "ERROR: cook failed" | tee -a $LOGS/$pkg.log
	fi
	# ERROR can be echoed any time in cookit()
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		debug_info | tee -a $LOGS/$pkg.log
		rm -f $command && exit 1
	fi
}

# Create the package. Wanted to use Tazpkg to create a tazpkg package at first,
# but it doesn't handle EXTRAVERSION.
packit() {
	set_paths
	echo "Pack: $PACKAGE $VERSION"
	separator
	if grep -q ^genpkg_rules $receipt; then
		gettext -e "Executing: genpkg_rules\n"
		cd $pkgdir
		mkdir -p $fs && genpkg_rules || echo -e \
			"\nERROR: genpkg_rules failed\n" >> $LOGS/$pkg.log
	fi

	# First QA check to stop now if genpkg_rules failed.
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		exit 1
	fi
	
	cd $taz
	for file in receipt description.txt
	do
		[ ! -f "../$file" ] && continue
		gettext "Copying"; echo -n " $file..."
		cp -f ../$file $pack && chown 0.0 $pack/$file && status
	done
	
	# Create files.list with redirecting find output.
	gettext "Creating the list of files..." && cd $fs
	find . -type f -print > ../files.list
	find . -type l -print >> ../files.list
	cd .. && sed -i s/'^.'/''/ files.list
	status

	# QA, strip and stuff files.
	
	strip_package
	copy_generic_files

	# Md5sum of files.
	gettext "Creating md5sum of files..."
	while read file; do
		[ -L "fs$file" ] && continue
		[ -f "fs$file" ] || continue
		case "$file" in
		/lib/modules/*/modules.*|*.pyc) continue;;
		esac
		md5sum "fs$file" | sed 's/  fs/  /'
	done < files.list > md5sum
	status
	UNPACKED_SIZE=$(du -chs fs receipt files.list md5sum \
		description.txt 2> /dev/null | awk \
		'{ sz=$1 } END { print sz }')
	
	# Build cpio archives.
	gettext "Compressing the fs... "
	find fs | cpio -o -H newc --quiet | lzma e fs.cpio.lzma -si
	rm -rf fs
	status
	PACKED_SIZE=$(du -chs fs.cpio.lzma receipt files.list \
		md5sum description.txt 2> /dev/null | awk \
		'{ sz=$1 } END { print sz }')
	gettext "Updating receipt sizes..."
	sed -i s/^PACKED_SIZE.*$// receipt
	sed -i s/^UNPACKED_SIZE.*$// receipt
	sed -i "s/^PACKAGE=/PACKED_SIZE=\"$PACKED_SIZE\"\nUNPACKED_SIZE=\"$UNPACKED_SIZE\"\nPACKAGE=/" receipt
	status

	# Set extra version.
	if [ "$EXTRAVERSION" ]; then
		gettext "Updating receipt EXTRAVERSION: "; echo -n "$EXTRAVERSION"
		sed -i s/^EXTRAVERSION.*$// receipt
		sed -i "s/^VERSION=/EXTRAVERSION=\"$EXTRAVERSION\"\nVERSION=/" receipt
		status
	fi

	# Compress.
	gettext "Creating full cpio archive... "
	find . -print | cpio -o -H newc --quiet > \
		../$PACKAGE-${VERSION}${EXTRAVERSION}.tazpkg
	status
	gettext "Restoring original package tree... "
	unlzma -c fs.cpio.lzma | cpio -idm --quiet
	status
	rm fs.cpio.lzma && cd ..

	# QA and give info.
	tazpkg=$(ls *.tazpkg)
	packit_quality
	separator && gettext "Package:"; echo -e " $tazpkg\n"
}

# Verify package quality and consistency.
packit_quality() {
	if fgrep -q ERROR: $LOGS/$pkg.log; then
		rm -f $command && exit 1
	fi
	gettext "QA: Checking for empty package..."
	files=$(cat $WOK/$pkg/taz/$pkg-*/files.list | wc -l)
	if [ "$files" -lt 0 ] && [ "$CATEGORY" != "meta" ]; then
		echo -e "\nERROR: empty package"
		rm -f $command && exit 1
	else
		status && mv -f $pkgdir/taz/$pkg-*.tazpkg $PKGS
		sed -i /^${pkg}$/d $broken
	fi
}

#
# Commands
#

case "$1" in
	usage|help|-u|-h)
		 usage ;;
	list-wok)
		gettext -e "\nList of packages in:"; echo " $WOK"
		separator
		cd $WOK && ls -1
		separator
		echo -n "Packages: " && ls | wc -l
		echo "" ;;
	search)
		# Just a simple search function, we dont need more actually.
		query="$2"
		gettext -e "\nSearch results for:"; echo " $query"
		separator
		cd $WOK && ls -1 | grep "$query"
		separator && echo "" ;;
	setup)
		# Setup a build environment
		check_root
		echo "Cook: setting up the environment" | log
		gettext -e "\nSetting up your environment\n"
		separator && cd $SLITAZ
		init_db_files
		gettext -e "Checking for packages to install...\n"
		for pkg in $SETUP_PKGS
		do
			[ ! -f "$INSTALLED/$pkg/receipt" ] && tazpkg get-install $pkg
		done

		# Handle --options
		case "$2" in
			--wok|-w)
				[ ! -f "$INSTALLED/mercurial/receipt" ] && \
					tazpkg get-install mercurial
				[ -d "$WOK" ] && echo -e "A wok already exists.\n" && exit 1
				hg clone $HG_URL ;;
		esac

		# SliTaz group and permissions
		if ! grep -q ^slitaz /etc/group; then
			gettext -e "Adding group: slitaz\n"
			addgroup slitaz
		fi
		gettext -e "Setting permissions for slitaz group...\n"
		chown -R root.slitaz $SLITAZ
		chmod -R g+w $SLITAZ
		separator
		gettext -e "All done, ready to cook packages :-)\n\n" ;;
	test)
		# Test a cook environment.
		echo "Cook test: testing the cook environment" | log
		[ ! -d "$WOK" ] && exit 1
		[ ! -d "$WOK/cooktest" ] && cp -r $DATA/cooktest $WOK
		cook cooktest ;;
	new)
		# Create the package folder and an empty receipt.
		pkg="$2"
		[ "$pkg" ] || usage
		[ -d "${WOK}-hg" ] && WOK=${WOK}-hg
		echo ""
		if [ -d "$WOK/$pkg" ]; then
			echo -n  "$pkg " && gettext "package already exists."
			echo -e "\n" && exit 1
		fi
		gettext "Creating"; echo -n " $WOK/$pkg"
		mkdir $WOK/$pkg && cd $WOK/$pkg && status
		gettext "Preparing the package receipt..."
		cp $DATA/receipt .
		sed -i s"/^PACKAGE=.*/PACKAGE=\"$pkg\"/" receipt
		status && echo "" ;;
	list)
		# Cook a list of packages (better use the Cooker since it will order
		# packages before executing cook).
		check_root
		[ -z "$2" ] && gettext -e "\nNo list in argument.\n\n" && exit 1
		[ ! -f "$2" ] && gettext -e "\nNo list found:" && \
			echo -e " $2\n" && exit 1
		echo "Cook list starting: $2" | log
		for pkg in $(cat $2)
		do
			cook $pkg || broken
		done ;;
	clean-wok)
		check_root
		gettext -e "\nCleaning all packages files..."
		rm -rf $WOK/*/taz $WOK/*/install $WOK/*/source
		status && echo "" ;;
	clean-src)
		check_root
		gettext -e "\nCleaning all packages sources..."
		rm -rf $WOK/*/source
		status && echo "" ;;
	pkglist)
		# Create suitable packages list for TazPKG and only for built packages.
		[ "$2" ] && PKGS="$2"
		[ ! -d "$PKGS" ] && \
			gettext -e "\nPackages directory doesn't exist\n\n" && exit 1
		cd $PKGS
		echo "Cook pkglist: Creating all packages lists" | log
		gettext -e "\nCreating lists for:"; echo " $PKGS"
		separator
		rm -f packages.* files.list*
		gettext -e "Creating: packages.list\n"
		ls -1 *.tazpkg | sed s'/.tazpkg//' > $PKGS/packages.list
		gettext -e "Creating: packages.md5\n"
		md5sum *.tazpkg > $PKGS/packages.md5
		gettext -e "Creating: packages.desc\n"
		gettext -e "Creating: packages.equiv\n"
		cd $WOK
		for pkg in *
		do
			unset_receipt
			. $pkg/receipt
			# packages.desc let us search easily in DB
			if [ -f "$PKGS/$PACKAGE-${VERSION}${EXTRAVERSION}.tazpkg" ]; then
				cat >> $PKGS/packages.desc << EOT
$PACKAGE | $VERSION$EXTRAVERSION | $SHORT_DESC | $CATEGORY | $WEB_SITE
EOT
				# Packages.equiv is used by tazpkg install to check depends.
				for i in $PROVIDE; do
					DEST=""
					echo $i | fgrep -q : && DEST="${i#*:}:"
					if grep -qs ^${i%:*}= $PKGS/packages.equiv; then
						sed -i "s/^${i%:*}=/${i%:*}=$DEST$PACKAGE /" \
							$PKGS/packages.equiv
					else
						echo "${i%:*}=$DEST$PACKAGE" >> $PKGS/packages.equiv
					fi
				done
			fi
		done
		# files.list.lzma
		#lzma e files.list files.list.lzma
		separator
		nb=$(ls $PKGS/*.tazpkg | wc -l)
		echo -e "Packages: $nb\n" ;;
	*)
		# Just cook and generate a package.
		check_root
		time=$(date +%s)
		pkg="$1"
		[ -z "$pkg" ] && usage
		receipt="$WOK/$pkg/receipt"
		check_pkg_in_wok && echo ""

		# Skip blocked, 3 lines also for the Cooker.
		if grep -q "^$pkg$" $blocked && [ "$2" != "--*" ]; then
			gettext -e "Blocked package:"; echo -e " $pkg\n" && exit 0
		fi

		# Log and source receipt.
		echo "Cook started for: <a href='cooker.cgi?pkg=$pkg'>$pkg</a>" | log
		echo "cook:$pkg" > $command
		unset inst
		unset_receipt
		. $receipt
		
		# Handle --options
		case "$2" in
			--clean|-c)
				gettext -e "Cleaning:"; echo -n " $pkg"
				cd $WOK/$pkg && rm -rf install taz source
				status && echo "" && exit 0 ;;
			--install|-i)
				inst='yes' ;;
			--getsrc|-gs)
				gettext "Getting source for:"; echo " $pkg"
				separator && get_source
				echo -e "Tarball: $SRC/$TARBALL\n" && exit 0 ;;
			--block|-b)
				gettext "Blocking:"; echo -n " $pkg"
				[ $(grep "^$pkg$" $blocked) ] || echo "$pkg" >> $blocked
				status && echo "" && exit 0 ;;
			--unblock|-ub)
				gettext "Unblocking:"; echo -n " $pkg"
				sed -i "/^${pkg}$/"d $blocked
				status && echo "" && exit 0 ;;
		esac

		# Check if wanted is built now so we have separate log files.
		if [ "$WANTED" ] && [ ! -d "$WOK/$WANTED/install" ]; then
			cook "$WANTED"
		fi

		# Cook and pack or exit on error and log everything.
		cookit $@ 2>&1 | tee $LOGS/$pkg.log
		remove_deps | tee -a $LOGS/$pkg.log
		cookit_quality
		packit 2>&1 | tee -a $LOGS/$pkg.log
		clean_log

		# Exit if any error in packing.
		if grep -q ^ERROR $LOGS/$pkg.log; then
			debug_info | tee -a $LOGS/$pkg.log
			rm -f $command && exit 1
		fi
		
		# Time and summary
		time=$(($(date +%s) - $time))
		summary | tee -a $LOGS/$pkg.log
		echo ""

		# Install package if requested
		if [ "$inst" ]; then
			if [ -f "$PKGS/$PACKAGE-${VERSION}${EXTRAVERSION}.tazpkg" ]; then
				cd $PKGS && tazpkg install \
					$PACKAGE-${VERSION}${EXTRAVERSION}.tazpkg --forced
			else
				gettext -e "Unable to install package, build has failed.\n\n"
				exit 1
			fi
		fi
		# Finally we DONT WANT to build the *-dev or packages with WANTED="$pkg"
		# You want automation: use the Cooker Build Bot.
		#[ -d "$WOK/$pkg-dev" ] && cook $pkg-dev
		rm -f $command ;;
esac

exit 0
